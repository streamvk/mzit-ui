/**
 * @license
 * Copyright 2013-present Dale Lotts All Rights Reserved.
 * http://www.dalelotts.com
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://github.com/dalelotts/angular-bootstrap-datetimepicker/blob/master/LICENSE
 */
import * as _moment from 'moment';
/**
 * Work around for moment namespace conflict when used with webpack and rollup.
 * See https://github.com/dherges/ng-packagr/issues/163
 *
 * Depending on whether rollup is used, moment needs to be imported differently.
 * Since Moment.js doesn't have a default export, we normally need to import using
 * the `* as`syntax.
 *
 * rollup creates a synthetic default module and we thus need to import it using
 * the `default as` syntax.
 *
 * @internal
 **/
var moment = _moment;
/**
 * Default implementation for the `hour` view.
 */
var DlHourModelProvider = /** @class */ (function () {
    function DlHourModelProvider() {
    }
    /**
     * Receives input changes detected by Angular.
     *
     * @param changes
     *  the input changes detected by Angular.
     */
    DlHourModelProvider.prototype.onChanges = function (
    // @ts-ignore
    changes) { };
    /**
     * Returns the `hour` model for the specified moment in `local` time with the
     * `active` hour set to the beginning of the day.
     *
     * The `hour` model represents a day (24 hours) as six rows with four columns
     * and each cell representing one-hour increments.
     *
     * The hour always starts at the beginning of the hour.
     *
     * Each cell represents a one-hour increment starting at midnight.
     *
     * @param milliseconds
     *  the moment in time from which the minute model will be created.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  the model representing the specified moment in time.
     */
    DlHourModelProvider.prototype.getModel = function (milliseconds, selectedMilliseconds) {
        var startDate = moment(milliseconds).startOf('day');
        var rowNumbers = [0, 1, 2, 3, 4, 5];
        var columnNumbers = [0, 1, 2, 3];
        var previousDay = moment(startDate).subtract(1, 'day');
        var nextDay = moment(startDate).add(1, 'day');
        var activeValue = moment(milliseconds).startOf('hour').valueOf();
        var selectedValue = selectedMilliseconds === null || selectedMilliseconds === undefined
            ? selectedMilliseconds
            : moment(selectedMilliseconds).startOf('hour').valueOf();
        return {
            viewName: 'hour',
            viewLabel: startDate.format('ll'),
            activeDate: activeValue,
            leftButton: {
                value: previousDay.valueOf(),
                ariaLabel: "Go to " + previousDay.format('ll'),
                classes: {},
            },
            upButton: {
                value: startDate.valueOf(),
                ariaLabel: "Go to " + startDate.format('MMM YYYY'),
                classes: {},
            },
            rightButton: {
                value: nextDay.valueOf(),
                ariaLabel: "Go to " + nextDay.format('ll'),
                classes: {},
            },
            rows: rowNumbers.map(rowOfHours)
        };
        function rowOfHours(rowNumber) {
            var currentMoment = moment();
            var cells = columnNumbers.map(function (columnNumber) {
                var hourMoment = moment(startDate).add((rowNumber * columnNumbers.length) + columnNumber, 'hours');
                return {
                    display: hourMoment.format('LT'),
                    ariaLabel: hourMoment.format('LLL'),
                    value: hourMoment.valueOf(),
                    classes: {
                        'dl-abdtp-active': activeValue === hourMoment.valueOf(),
                        'dl-abdtp-selected': selectedValue === hourMoment.valueOf(),
                        'dl-abdtp-now': hourMoment.isSame(currentMoment, 'hour'),
                    }
                };
            });
            return { cells: cells };
        }
    };
    /**
     * Move the active `hour` one row `down` from the specified moment in time.
     *
     * Moving `down` can result in the `active` hour being part of a different day than
     * the specified `fromMilliseconds`, in this case the day represented by the model
     * will change to show the correct hour.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `hour` model `down` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `hour` one row `down` from the specified moment in time.
     */
    DlHourModelProvider.prototype.goDown = function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).add(4, 'hour').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the active `hour` one row `up` from the specified moment in time.
     *
     * Moving `up` can result in the `active` hour being part of a different day than
     * the specified `fromMilliseconds`, in this case the day represented by the model
     * will change to show the correct hour.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `hour` model `up` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `hour` one row `up` from the specified moment in time.
     */
    DlHourModelProvider.prototype.goUp = function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).subtract(4, 'hour').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the `active` hour one cell `left` in the current `hour` view.
     *
     * Moving `left` can result in the `active` hour being part of a different day than
     * the specified `fromMilliseconds`, in this case the day represented by the model
     * will change to show the correct year.
     *
     * @param fromMilliseconds
     *  the moment in time from which the `hour` model to the `left` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `hour` one cell to the `left` of the specified moment in time.
     */
    DlHourModelProvider.prototype.goLeft = function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).subtract(1, 'hour').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the `active` hour one cell `right` in the current `hour` view.
     *
     * Moving `right` can result in the `active` hour being part of a different day than
     * the specified `fromMilliseconds`, in this case the day represented by the model
     * will change to show the correct year.
     *
     * @param fromMilliseconds
     *  the moment in time from which the `hour` model to the `right` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `hour` one cell to the `right` of the specified moment in time.
     */
    DlHourModelProvider.prototype.goRight = function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).add(1, 'hour').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the active `hour` one day `down` from the specified moment in time.
     *
     * Paging `down` will result in the `active` hour being part of a different day than
     * the specified `fromMilliseconds`. As a result, the day represented by the model
     * will change to show the correct year.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `hour` model page `down` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `hour` one day `down` from the specified moment in time.
     */
    DlHourModelProvider.prototype.pageDown = function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).add(1, 'day').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the active `hour` one day `up` from the specified moment in time.
     *
     * Paging `up` will result in the `active` hour being part of a different day than
     * the specified `fromMilliseconds`. As a result, the day represented by the model
     * will change to show the correct year.
     *
     * @param fromMilliseconds
     *  the moment in time from which the next `hour` model page `up` will be constructed.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  model containing an `active` `hour` one day `up` from the specified moment in time.
     */
    DlHourModelProvider.prototype.pageUp = function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).subtract(1, 'day').valueOf(), selectedMilliseconds);
    };
    /**
     * Move the `active` `hour` to `11:00 pm` of the current day.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different day than the displayed decade.
     *
     * @param fromMilliseconds
     *  the moment in time from which `11:00 pm` will be calculated.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  a model with the `11:00 pm` cell in the view as the active `hour`.
     */
    DlHourModelProvider.prototype.goEnd = function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds)
            .endOf('day')
            .startOf('hour')
            .valueOf(), selectedMilliseconds);
    };
    /**
     * Move the `active` `hour` to `midnight` of the current day.
     *
     * The view or time range will not change unless the `fromMilliseconds` value
     * is in a different day than the displayed decade.
     *
     * @param fromMilliseconds
     *  the moment in time from which `midnight` will be calculated.
     * @param selectedMilliseconds
     *  the current value of the date/time picker.
     * @returns
     *  a model with the `midnight` cell in the view as the active `hour`.
     */
    DlHourModelProvider.prototype.goHome = function (fromMilliseconds, selectedMilliseconds) {
        return this.getModel(moment(fromMilliseconds).startOf('day').valueOf(), selectedMilliseconds);
    };
    return DlHourModelProvider;
}());
export { DlHourModelProvider };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGwtbW9kZWwtcHJvdmlkZXItaG91ci5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2FuZ3VsYXItYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLyIsInNvdXJjZXMiOlsiZGwtZGF0ZS10aW1lLXBpY2tlci9kbC1tb2RlbC1wcm92aWRlci1ob3VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7O0dBT0c7QUFHSCxPQUFPLEtBQUssT0FBTyxNQUFNLFFBQVEsQ0FBQztBQUlsQzs7Ozs7Ozs7Ozs7O0lBWUk7QUFDSixJQUFNLE1BQU0sR0FBRyxPQUFPLENBQUM7QUFFdkI7O0dBRUc7QUFDSDtJQUFBO0lBd09BLENBQUM7SUF0T0M7Ozs7O09BS0c7SUFDSCx1Q0FBUyxHQUFUO0lBQ0UsYUFBYTtJQUNiLE9BQXNCLElBQ2YsQ0FBQztJQUdWOzs7Ozs7Ozs7Ozs7Ozs7OztPQWlCRztJQUNILHNDQUFRLEdBQVIsVUFBUyxZQUFvQixFQUFFLG9CQUE0QjtRQUN6RCxJQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRXRELElBQU0sVUFBVSxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN0QyxJQUFNLGFBQWEsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLEVBQUUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1FBRW5DLElBQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ3pELElBQU0sT0FBTyxHQUFHLE1BQU0sQ0FBQyxTQUFTLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEtBQUssQ0FBQyxDQUFDO1FBQ2hELElBQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxZQUFZLENBQUMsQ0FBQyxPQUFPLENBQUMs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S0FBSyxDQUFDO2FBQ1osT0FBTyxDQUFDLE1BQU0sQ0FBQzthQUNmLE9BQU8sRUFBRSxFQUFFLG9CQUFvQixDQUFDLENBQUM7SUFDdEMsQ0FBQztJQUVEOzs7Ozs7Ozs7Ozs7T0FZRztJQUNILG9DQUFNLEdBQU4sVUFBTyxnQkFBd0IsRUFBRSxvQkFBNEI7UUFDM0QsT0FBTyxJQUFJLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxPQUFPLEVBQUUsRUFBRSxvQkFBb0IsQ0FBQyxDQUFDO0lBQ2hHLENBQUM7SUFDSCwwQkFBQztBQUFELENBQUMsQUF4T0QsSUF3T0MiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxMy1wcmVzZW50IERhbGUgTG90dHMgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIGh0dHA6Ly93d3cuZGFsZWxvdHRzLmNvbVxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9kYWxlbG90dHMvYW5ndWxhci1ib290c3RyYXAtZGF0ZXRpbWVwaWNrZXIvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICovXG5cbmltcG9ydCB7U2ltcGxlQ2hhbmdlc30gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgKiBhcyBfbW9tZW50IGZyb20gJ21vbWVudCc7XG5pbXBvcnQge0RsRGF0ZVRpbWVQaWNrZXJNb2RlbH0gZnJvbSAnLi9kbC1kYXRlLXRpbWUtcGlja2VyLW1vZGVsJztcbmltcG9ydCB7RGxNb2RlbFByb3ZpZGVyfSBmcm9tICcuL2RsLW1vZGVsLXByb3ZpZGVyJztcblxuLyoqXG4gKiBXb3JrIGFyb3VuZCBmb3IgbW9tZW50IG5hbWVzcGFjZSBjb25mbGljdCB3aGVuIHVzZWQgd2l0aCB3ZWJwYWNrIGFuZCByb2xsdXAuXG4gKiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2RoZXJnZXMvbmctcGFja2Fnci9pc3N1ZXMvMTYzXG4gKlxuICogRGVwZW5kaW5nIG9uIHdoZXRoZXIgcm9sbHVwIGlzIHVzZWQsIG1vbWVudCBuZWVkcyB0byBiZSBpbXBvcnRlZCBkaWZmZXJlbnRseS5cbiAqIFNpbmNlIE1vbWVudC5qcyBkb2Vzbid0IGhhdmUgYSBkZWZhdWx0IGV4cG9ydCwgd2Ugbm9ybWFsbHkgbmVlZCB0byBpbXBvcnQgdXNpbmdcbiAqIHRoZSBgKiBhc2BzeW50YXguXG4gKlxuICogcm9sbHVwIGNyZWF0ZXMgYSBzeW50aGV0aWMgZGVmYXVsdCBtb2R1bGUgYW5kIHdlIHRodXMgbmVlZCB0byBpbXBvcnQgaXQgdXNpbmdcbiAqIHRoZSBgZGVmYXVsdCBhc2Agc3ludGF4LlxuICpcbiAqIEBpbnRlcm5hbFxuICoqL1xuY29uc3QgbW9tZW50ID0gX21vbWVudDtcblxuLyoqXG4gKiBEZWZhdWx0IGltcGxlbWVudGF0aW9uIGZvciB0aGUgYGhvdXJgIHZpZXcuXG4gKi9cbmV4cG9ydCBjbGFzcyBEbEhvdXJNb2RlbFByb3ZpZGVyIGltcGxlbWVudHMgRGxNb2RlbFByb3ZpZGVyIHtcblxuICAvKipcbiAgICogUmVjZWl2ZXMgaW5wdXQgY2hhbmdlcyBkZXRlY3RlZCBieSBBbmd1bGFyLlxuICAgKlxuICAgKiBAcGFyYW0gY2hhbmdlc1xuICAgKiAgdGhlIGlucHV0IGNoYW5nZXMgZGV0ZWN0ZWQgYnkgQW5ndWxhci5cbiAgICovXG4gIG9uQ2hhbmdlcyhcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY2hhbmdlczogU2ltcGxlQ2hhbmdlc1xuICApOiB2b2lkIHt9XG5cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYGhvdXJgIG1vZGVsIGZvciB0aGUgc3BlY2lmaWVkIG1vbWVudCBpbiBgbG9jYWxgIHRpbWUgd2l0aCB0aGVcbiAgICogYGFjdGl2ZWAgaG91ciBzZXQgdG8gdGhlIGJlZ2lubmluZyBvZiB0aGUgZGF5LlxuICAgKlxuICAgKiBUaGUgYGhvdXJgIG1vZGVsIHJlcHJlc2VudHMgYSBkYXkgKDI0IGhvdXJzKSBhcyBzaXggcm93cyB3aXRoIGZvdXIgY29sdW1uc1xuICAgKiBhbmQgZWFjaCBjZWxsIHJlcHJlc2VudGluZyBvbmUtaG91ciBpbmNyZW1lbnRzLlxuICAgKlxuICAgKiBUaGUgaG91ciBhbHdheXMgc3RhcnRzIGF0IHRoZSBiZWdpbm5pbmcgb2YgdGhlIGhvdXIuXG4gICAqXG4gICAqIEVhY2ggY2VsbCByZXByZXNlbnRzIGEgb25lLWhvdXIgaW5jcmVtZW50IHN0YXJ0aW5nIGF0IG1pZG5pZ2h0LlxuICAgKlxuICAgKiBAcGFyYW0gbWlsbGlzZWNvbmRzXG4gICAqICB0aGUgbW9tZW50IGluIHRpbWUgZnJvbSB3aGljaCB0aGUgbWludXRlIG1vZGVsIHdpbGwgYmUgY3JlYXRlZC5cbiAgICogQHBhcmFtIHNlbGVjdGVkTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgZGF0ZS90aW1lIHBpY2tlci5cbiAgICogQHJldHVybnNcbiAgICogIHRoZSBtb2RlbCByZXByZXNlbnRpbmcgdGhlIHNwZWNpZmllZCBtb21lbnQgaW4gdGltZS5cbiAgICovXG4gIGdldE1vZGVsKG1pbGxpc2Vjb25kczogbnVtYmVyLCBzZWxlY3RlZE1pbGxpc2Vjb25kczogbnVtYmVyKTogRGxEYXRlVGltZVBpY2tlck1vZGVsIHtcbiAgICBjb25zdCBzdGFydERhdGUgPSBtb21lbnQobWlsbGlzZWNvbmRzKS5zdGFydE9mKCdkYXknKTtcblxuICAgIGNvbnN0IHJvd051bWJlcnMgPSBbMCwgMSwgMiwgMywgNCwgNV07XG4gICAgY29uc3QgY29sdW1uTnVtYmVycyA9IFswLCAxLCAyLCAzXTtcblxuICAgIGNvbnN0IHByZXZpb3VzRGF5ID0gbW9tZW50KHN0YXJ0RGF0ZSkuc3VidHJhY3QoMSwgJ2RheScpO1xuICAgIGNvbnN0IG5leHREYXkgPSBtb21lbnQoc3RhcnREYXRlKS5hZGQoMSwgJ2RheScpO1xuICAgIGNvbnN0IGFjdGl2ZVZhbHVlID0gbW9tZW50KG1pbGxpc2Vjb25kcykuc3RhcnRPZignaG91cicpLnZhbHVlT2YoKTtcbiAgICBjb25zdCBzZWxlY3RlZFZhbHVlID0gc2VsZWN0ZWRNaWxsaXNlY29uZHMgPT09IG51bGwgfHwgc2VsZWN0ZWRNaWxsaXNlY29uZHMgPT09IHVuZGVmaW5lZFxuICAgICAgPyBzZWxlY3RlZE1pbGxpc2Vjb25kc1xuICAgICAgOiBtb21lbnQoc2VsZWN0ZWRNaWxsaXNlY29uZHMpLnN0YXJ0T2YoJ2hvdXInKS52YWx1ZU9mKCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgdmlld05hbWU6ICdob3VyJyxcbiAgICAgIHZpZXdMYWJlbDogc3RhcnREYXRlLmZvcm1hdCgnbGwnKSxcbiAgICAgIGFjdGl2ZURhdGU6IGFjdGl2ZVZhbHVlLFxuICAgICAgbGVmdEJ1dHRvbjoge1xuICAgICAgICB2YWx1ZTogcHJldmlvdXNEYXkudmFsdWVPZigpLFxuICAgICAgICBhcmlhTGFiZWw6IGBHbyB0byAke3ByZXZpb3VzRGF5LmZvcm1hdCgnbGwnKX1gLFxuICAgICAgICBjbGFzc2VzOiB7fSxcbiAgICAgIH0sXG4gICAgICB1cEJ1dHRvbjoge1xuICAgICAgICB2YWx1ZTogc3RhcnREYXRlLnZhbHVlT2YoKSxcbiAgICAgICAgYXJpYUxhYmVsOiBgR28gdG8gJHtzdGFydERhdGUuZm9ybWF0KCdNTU0gWVlZWScpfWAsXG4gICAgICAgIGNsYXNzZXM6IHt9LFxuICAgICAgfSxcbiAgICAgIHJpZ2h0QnV0dG9uOiB7XG4gICAgICAgIHZhbHVlOiBuZXh0RGF5LnZhbHVlT2YoKSxcbiAgICAgICAgYXJpYUxhYmVsOiBgR28gdG8gJHtuZXh0RGF5LmZvcm1hdCgnbGwnKX1gLFxuICAgICAgICBjbGFzc2VzOiB7fSxcbiAgICAgIH0sXG4gICAgICByb3dzOiByb3dOdW1iZXJzLm1hcChyb3dPZkhvdXJzKVxuICAgIH07XG5cbiAgICBmdW5jdGlvbiByb3dPZkhvdXJzKHJvd051bWJlcikge1xuXG4gICAgICBjb25zdCBjdXJyZW50TW9tZW50ID0gbW9tZW50KCk7XG4gICAgICBjb25zdCBjZWxscyA9IGNvbHVtbk51bWJlcnMubWFwKChjb2x1bW5OdW1iZXIpID0+IHtcbiAgICAgICAgY29uc3QgaG91ck1vbWVudCA9IG1vbWVudChzdGFydERhdGUpLmFkZCgocm93TnVtYmVyICogY29sdW1uTnVtYmVycy5sZW5ndGgpICsgY29sdW1uTnVtYmVyLCAnaG91cnMnKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBkaXNwbGF5OiBob3VyTW9tZW50LmZvcm1hdCgnTFQnKSxcbiAgICAgICAgICBhcmlhTGFiZWw6IGhvdXJNb21lbnQuZm9ybWF0KCdMTEwnKSxcbiAgICAgICAgICB2YWx1ZTogaG91ck1vbWVudC52YWx1ZU9mKCksXG4gICAgICAgICAgY2xhc3Nlczoge1xuICAgICAgICAgICAgJ2RsLWFiZHRwLWFjdGl2ZSc6IGFjdGl2ZVZhbHVlID09PSBob3VyTW9tZW50LnZhbHVlT2YoKSxcbiAgICAgICAgICAgICdkbC1hYmR0cC1zZWxlY3RlZCc6IHNlbGVjdGVkVmFsdWUgPT09IGhvdXJNb21lbnQudmFsdWVPZigpLFxuICAgICAgICAgICAgJ2RsLWFiZHRwLW5vdyc6IGhvdXJNb21lbnQuaXNTYW1lKGN1cnJlbnRNb21lbnQsICdob3VyJyksXG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4ge2NlbGxzfTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogTW92ZSB0aGUgYWN0aXZlIGBob3VyYCBvbmUgcm93IGBkb3duYCBmcm9tIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAqXG4gICAqIE1vdmluZyBgZG93bmAgY2FuIHJlc3VsdCBpbiB0aGUgYGFjdGl2ZWAgaG91ciBiZWluZyBwYXJ0IG9mIGEgZGlmZmVyZW50IGRheSB0aGFuXG4gICAqIHRoZSBzcGVjaWZpZWQgYGZyb21NaWxsaXNlY29uZHNgLCBpbiB0aGlzIGNhc2UgdGhlIGRheSByZXByZXNlbnRlZCBieSB0aGUgbW9kZWxcbiAgICogd2lsbCBjaGFuZ2UgdG8gc2hvdyB0aGUgY29ycmVjdCBob3VyLlxuICAgKlxuICAgKiBAcGFyYW0gZnJvbU1pbGxpc2Vjb25kc1xuICAgKiAgdGhlIG1vbWVudCBpbiB0aW1lIGZyb20gd2hpY2ggdGhlIG5leHQgYGhvdXJgIG1vZGVsIGBkb3duYCB3aWxsIGJlIGNvbnN0cnVjdGVkLlxuICAgKiBAcGFyYW0gc2VsZWN0ZWRNaWxsaXNlY29uZHNcbiAgICogIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgcGlja2VyLlxuICAgKiBAcmV0dXJuc1xuICAgKiAgbW9kZWwgY29udGFpbmluZyBhbiBgYWN0aXZlYCBgaG91cmAgb25lIHJvdyBgZG93bmAgZnJvbSB0aGUgc3BlY2lmaWVkIG1vbWVudCBpbiB0aW1lLlxuICAgKi9cbiAgZ29Eb3duKGZyb21NaWxsaXNlY29uZHM6IG51bWJlciwgc2VsZWN0ZWRNaWxsaXNlY29uZHM6IG51bWJlcik6IERsRGF0ZVRpbWVQaWNrZXJNb2RlbCB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TW9kZWwobW9tZW50KGZyb21NaWxsaXNlY29uZHMpLmFkZCg0LCAnaG91cicpLnZhbHVlT2YoKSwgc2VsZWN0ZWRNaWxsaXNlY29uZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIGFjdGl2ZSBgaG91cmAgb25lIHJvdyBgdXBgIGZyb20gdGhlIHNwZWNpZmllZCBtb21lbnQgaW4gdGltZS5cbiAgICpcbiAgICogTW92aW5nIGB1cGAgY2FuIHJlc3VsdCBpbiB0aGUgYGFjdGl2ZWAgaG91ciBiZWluZyBwYXJ0IG9mIGEgZGlmZmVyZW50IGRheSB0aGFuXG4gICAqIHRoZSBzcGVjaWZpZWQgYGZyb21NaWxsaXNlY29uZHNgLCBpbiB0aGlzIGNhc2UgdGhlIGRheSByZXByZXNlbnRlZCBieSB0aGUgbW9kZWxcbiAgICogd2lsbCBjaGFuZ2UgdG8gc2hvdyB0aGUgY29ycmVjdCBob3VyLlxuICAgKlxuICAgKiBAcGFyYW0gZnJvbU1pbGxpc2Vjb25kc1xuICAgKiAgdGhlIG1vbWVudCBpbiB0aW1lIGZyb20gd2hpY2ggdGhlIG5leHQgYGhvdXJgIG1vZGVsIGB1cGAgd2lsbCBiZSBjb25zdHJ1Y3RlZC5cbiAgICogQHBhcmFtIHNlbGVjdGVkTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgZGF0ZS90aW1lIHBpY2tlci5cbiAgICogQHJldHVybnNcbiAgICogIG1vZGVsIGNvbnRhaW5pbmcgYW4gYGFjdGl2ZWAgYGhvdXJgIG9uZSByb3cgYHVwYCBmcm9tIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAqL1xuICBnb1VwKGZyb21NaWxsaXNlY29uZHM6IG51bWJlciwgc2VsZWN0ZWRNaWxsaXNlY29uZHM6IG51bWJlcik6IERsRGF0ZVRpbWVQaWNrZXJNb2RlbCB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TW9kZWwobW9tZW50KGZyb21NaWxsaXNlY29uZHMpLnN1YnRyYWN0KDQsICdob3VyJykudmFsdWVPZigpLCBzZWxlY3RlZE1pbGxpc2Vjb25kcyk7XG4gIH1cblxuICAvKipcbiAgICogTW92ZSB0aGUgYGFjdGl2ZWAgaG91ciBvbmUgY2VsbCBgbGVmdGAgaW4gdGhlIGN1cnJlbnQgYGhvdXJgIHZpZXcuXG4gICAqXG4gICAqIE1vdmluZyBgbGVmdGAgY2FuIHJlc3VsdCBpbiB0aGUgYGFjdGl2ZWAgaG91ciBiZWluZyBwYXJ0IG9mIGEgZGlmZmVyZW50IGRheSB0aGFuXG4gICAqIHRoZSBzcGVjaWZpZWQgYGZyb21NaWxsaXNlY29uZHNgLCBpbiB0aGlzIGNhc2UgdGhlIGRheSByZXByZXNlbnRlZCBieSB0aGUgbW9kZWxcbiAgICogd2lsbCBjaGFuZ2UgdG8gc2hvdyB0aGUgY29ycmVjdCB5ZWFyLlxuICAgKlxuICAgKiBAcGFyYW0gZnJvbU1pbGxpc2Vjb25kc1xuICAgKiAgdGhlIG1vbWVudCBpbiB0aW1lIGZyb20gd2hpY2ggdGhlIGBob3VyYCBtb2RlbCB0byB0aGUgYGxlZnRgIHdpbGwgYmUgY29uc3RydWN0ZWQuXG4gICAqIEBwYXJhbSBzZWxlY3RlZE1pbGxpc2Vjb25kc1xuICAgKiAgdGhlIGN1cnJlbnQgdmFsdWUgb2YgdGhlIGRhdGUvdGltZSBwaWNrZXIuXG4gICAqIEByZXR1cm5zXG4gICAqICBtb2RlbCBjb250YWluaW5nIGFuIGBhY3RpdmVgIGBob3VyYCBvbmUgY2VsbCB0byB0aGUgYGxlZnRgIG9mIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAqL1xuICBnb0xlZnQoZnJvbU1pbGxpc2Vjb25kczogbnVtYmVyLCBzZWxlY3RlZE1pbGxpc2Vjb25kczogbnVtYmVyKTogRGxEYXRlVGltZVBpY2tlck1vZGVsIHtcbiAgICByZXR1cm4gdGhpcy5nZXRNb2RlbChtb21lbnQoZnJvbU1pbGxpc2Vjb25kcykuc3VidHJhY3QoMSwgJ2hvdXInKS52YWx1ZU9mKCksIHNlbGVjdGVkTWlsbGlzZWNvbmRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNb3ZlIHRoZSBgYWN0aXZlYCBob3VyIG9uZSBjZWxsIGByaWdodGAgaW4gdGhlIGN1cnJlbnQgYGhvdXJgIHZpZXcuXG4gICAqXG4gICAqIE1vdmluZyBgcmlnaHRgIGNhbiByZXN1bHQgaW4gdGhlIGBhY3RpdmVgIGhvdXIgYmVpbmcgcGFydCBvZiBhIGRpZmZlcmVudCBkYXkgdGhhblxuICAgKiB0aGUgc3BlY2lmaWVkIGBmcm9tTWlsbGlzZWNvbmRzYCwgaW4gdGhpcyBjYXNlIHRoZSBkYXkgcmVwcmVzZW50ZWQgYnkgdGhlIG1vZGVsXG4gICAqIHdpbGwgY2hhbmdlIHRvIHNob3cgdGhlIGNvcnJlY3QgeWVhci5cbiAgICpcbiAgICogQHBhcmFtIGZyb21NaWxsaXNlY29uZHNcbiAgICogIHRoZSBtb21lbnQgaW4gdGltZSBmcm9tIHdoaWNoIHRoZSBgaG91cmAgbW9kZWwgdG8gdGhlIGByaWdodGAgd2lsbCBiZSBjb25zdHJ1Y3RlZC5cbiAgICogQHBhcmFtIHNlbGVjdGVkTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgZGF0ZS90aW1lIHBpY2tlci5cbiAgICogQHJldHVybnNcbiAgICogIG1vZGVsIGNvbnRhaW5pbmcgYW4gYGFjdGl2ZWAgYGhvdXJgIG9uZSBjZWxsIHRvIHRoZSBgcmlnaHRgIG9mIHRoZSBzcGVjaWZpZWQgbW9tZW50IGluIHRpbWUuXG4gICAqL1xuICBnb1JpZ2h0KGZyb21NaWxsaXNlY29uZHM6IG51bWJlciwgc2VsZWN0ZWRNaWxsaXNlY29uZHM6IG51bWJlcik6IERsRGF0ZVRpbWVQaWNrZXJNb2RlbCB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TW9kZWwobW9tZW50KGZyb21NaWxsaXNlY29uZHMpLmFkZCgxLCAnaG91cicpLnZhbHVlT2YoKSwgc2VsZWN0ZWRNaWxsaXNlY29uZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIGFjdGl2ZSBgaG91cmAgb25lIGRheSBgZG93bmAgZnJvbSB0aGUgc3BlY2lmaWVkIG1vbWVudCBpbiB0aW1lLlxuICAgKlxuICAgKiBQYWdpbmcgYGRvd25gIHdpbGwgcmVzdWx0IGluIHRoZSBgYWN0aXZlYCBob3VyIGJlaW5nIHBhcnQgb2YgYSBkaWZmZXJlbnQgZGF5IHRoYW5cbiAgICogdGhlIHNwZWNpZmllZCBgZnJvbU1pbGxpc2Vjb25kc2AuIEFzIGEgcmVzdWx0LCB0aGUgZGF5IHJlcHJlc2VudGVkIGJ5IHRoZSBtb2RlbFxuICAgKiB3aWxsIGNoYW5nZSB0byBzaG93IHRoZSBjb3JyZWN0IHllYXIuXG4gICAqXG4gICAqIEBwYXJhbSBmcm9tTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgbW9tZW50IGluIHRpbWUgZnJvbSB3aGljaCB0aGUgbmV4dCBgaG91cmAgbW9kZWwgcGFnZSBgZG93bmAgd2lsbCBiZSBjb25zdHJ1Y3RlZC5cbiAgICogQHBhcmFtIHNlbGVjdGVkTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgZGF0ZS90aW1lIHBpY2tlci5cbiAgICogQHJldHVybnNcbiAgICogIG1vZGVsIGNvbnRhaW5pbmcgYW4gYGFjdGl2ZWAgYGhvdXJgIG9uZSBkYXkgYGRvd25gIGZyb20gdGhlIHNwZWNpZmllZCBtb21lbnQgaW4gdGltZS5cbiAgICovXG4gIHBhZ2VEb3duKGZyb21NaWxsaXNlY29uZHM6IG51bWJlciwgc2VsZWN0ZWRNaWxsaXNlY29uZHM6IG51bWJlcik6IERsRGF0ZVRpbWVQaWNrZXJNb2RlbCB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TW9kZWwobW9tZW50KGZyb21NaWxsaXNlY29uZHMpLmFkZCgxLCAnZGF5JykudmFsdWVPZigpLCBzZWxlY3RlZE1pbGxpc2Vjb25kcyk7XG4gIH1cblxuICAvKipcbiAgICogTW92ZSB0aGUgYWN0aXZlIGBob3VyYCBvbmUgZGF5IGB1cGAgZnJvbSB0aGUgc3BlY2lmaWVkIG1vbWVudCBpbiB0aW1lLlxuICAgKlxuICAgKiBQYWdpbmcgYHVwYCB3aWxsIHJlc3VsdCBpbiB0aGUgYGFjdGl2ZWAgaG91ciBiZWluZyBwYXJ0IG9mIGEgZGlmZmVyZW50IGRheSB0aGFuXG4gICAqIHRoZSBzcGVjaWZpZWQgYGZyb21NaWxsaXNlY29uZHNgLiBBcyBhIHJlc3VsdCwgdGhlIGRheSByZXByZXNlbnRlZCBieSB0aGUgbW9kZWxcbiAgICogd2lsbCBjaGFuZ2UgdG8gc2hvdyB0aGUgY29ycmVjdCB5ZWFyLlxuICAgKlxuICAgKiBAcGFyYW0gZnJvbU1pbGxpc2Vjb25kc1xuICAgKiAgdGhlIG1vbWVudCBpbiB0aW1lIGZyb20gd2hpY2ggdGhlIG5leHQgYGhvdXJgIG1vZGVsIHBhZ2UgYHVwYCB3aWxsIGJlIGNvbnN0cnVjdGVkLlxuICAgKiBAcGFyYW0gc2VsZWN0ZWRNaWxsaXNlY29uZHNcbiAgICogIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgcGlja2VyLlxuICAgKiBAcmV0dXJuc1xuICAgKiAgbW9kZWwgY29udGFpbmluZyBhbiBgYWN0aXZlYCBgaG91cmAgb25lIGRheSBgdXBgIGZyb20gdGhlIHNwZWNpZmllZCBtb21lbnQgaW4gdGltZS5cbiAgICovXG4gIHBhZ2VVcChmcm9tTWlsbGlzZWNvbmRzOiBudW1iZXIsIHNlbGVjdGVkTWlsbGlzZWNvbmRzOiBudW1iZXIpOiBEbERhdGVUaW1lUGlja2VyTW9kZWwge1xuICAgIHJldHVybiB0aGlzLmdldE1vZGVsKG1vbWVudChmcm9tTWlsbGlzZWNvbmRzKS5zdWJ0cmFjdCgxLCAnZGF5JykudmFsdWVPZigpLCBzZWxlY3RlZE1pbGxpc2Vjb25kcyk7XG4gIH1cblxuICAvKipcbiAgICogTW92ZSB0aGUgYGFjdGl2ZWAgYGhvdXJgIHRvIGAxMTowMCBwbWAgb2YgdGhlIGN1cnJlbnQgZGF5LlxuICAgKlxuICAgKiBUaGUgdmlldyBvciB0aW1lIHJhbmdlIHdpbGwgbm90IGNoYW5nZSB1bmxlc3MgdGhlIGBmcm9tTWlsbGlzZWNvbmRzYCB2YWx1ZVxuICAgKiBpcyBpbiBhIGRpZmZlcmVudCBkYXkgdGhhbiB0aGUgZGlzcGxheWVkIGRlY2FkZS5cbiAgICpcbiAgICogQHBhcmFtIGZyb21NaWxsaXNlY29uZHNcbiAgICogIHRoZSBtb21lbnQgaW4gdGltZSBmcm9tIHdoaWNoIGAxMTowMCBwbWAgd2lsbCBiZSBjYWxjdWxhdGVkLlxuICAgKiBAcGFyYW0gc2VsZWN0ZWRNaWxsaXNlY29uZHNcbiAgICogIHRoZSBjdXJyZW50IHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgcGlja2VyLlxuICAgKiBAcmV0dXJuc1xuICAgKiAgYSBtb2RlbCB3aXRoIHRoZSBgMTE6MDAgcG1gIGNlbGwgaW4gdGhlIHZpZXcgYXMgdGhlIGFjdGl2ZSBgaG91cmAuXG4gICAqL1xuICBnb0VuZChmcm9tTWlsbGlzZWNvbmRzOiBudW1iZXIsIHNlbGVjdGVkTWlsbGlzZWNvbmRzOiBudW1iZXIpOiBEbERhdGVUaW1lUGlja2VyTW9kZWwge1xuICAgIHJldHVybiB0aGlzLmdldE1vZGVsKG1vbWVudFxuICAgIChmcm9tTWlsbGlzZWNvbmRzKVxuICAgICAgLmVuZE9mKCdkYXknKVxuICAgICAgLnN0YXJ0T2YoJ2hvdXInKVxuICAgICAgLnZhbHVlT2YoKSwgc2VsZWN0ZWRNaWxsaXNlY29uZHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1vdmUgdGhlIGBhY3RpdmVgIGBob3VyYCB0byBgbWlkbmlnaHRgIG9mIHRoZSBjdXJyZW50IGRheS5cbiAgICpcbiAgICogVGhlIHZpZXcgb3IgdGltZSByYW5nZSB3aWxsIG5vdCBjaGFuZ2UgdW5sZXNzIHRoZSBgZnJvbU1pbGxpc2Vjb25kc2AgdmFsdWVcbiAgICogaXMgaW4gYSBkaWZmZXJlbnQgZGF5IHRoYW4gdGhlIGRpc3BsYXllZCBkZWNhZGUuXG4gICAqXG4gICAqIEBwYXJhbSBmcm9tTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgbW9tZW50IGluIHRpbWUgZnJvbSB3aGljaCBgbWlkbmlnaHRgIHdpbGwgYmUgY2FsY3VsYXRlZC5cbiAgICogQHBhcmFtIHNlbGVjdGVkTWlsbGlzZWNvbmRzXG4gICAqICB0aGUgY3VycmVudCB2YWx1ZSBvZiB0aGUgZGF0ZS90aW1lIHBpY2tlci5cbiAgICogQHJldHVybnNcbiAgICogIGEgbW9kZWwgd2l0aCB0aGUgYG1pZG5pZ2h0YCBjZWxsIGluIHRoZSB2aWV3IGFzIHRoZSBhY3RpdmUgYGhvdXJgLlxuICAgKi9cbiAgZ29Ib21lKGZyb21NaWxsaXNlY29uZHM6IG51bWJlciwgc2VsZWN0ZWRNaWxsaXNlY29uZHM6IG51bWJlcik6IERsRGF0ZVRpbWVQaWNrZXJNb2RlbCB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0TW9kZWwobW9tZW50KGZyb21NaWxsaXNlY29uZHMpLnN0YXJ0T2YoJ2RheScpLnZhbHVlT2YoKSwgc2VsZWN0ZWRNaWxsaXNlY29uZHMpO1xuICB9XG59XG4iXX0=