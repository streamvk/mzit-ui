import * as tslib_1 from "tslib";
import { Directive, ElementRef, EventEmitter, HostListener, Inject, Input, Output, Renderer2 } from '@angular/core';
import { NG_VALIDATORS, NG_VALUE_ACCESSOR, Validators, } from '@angular/forms';
import * as _moment from 'moment';
import { DL_DATE_TIME_DISPLAY_FORMAT, DL_DATE_TIME_INPUT_FORMATS, DlDateAdapter } from '../core/public-api';
import { DlDateTimeInputChange } from './dl-date-time-input-change';
/**
 * @internal
 */
var moment = _moment;
/**
 *  This directive allows the user to enter dates, using the keyboard, into an input box and
 *  angular will then store a date value in the model.
 *
 *  The input format(s), display format, and model format are independent and fully customizable.
 */
var DlDateTimeInputDirective = /** @class */ (function () {
    /**
     * Constructs a new instance of this directive.
     * @param _renderer
     *  reference to the renderer.
     * @param _elementRef
     *  reference to this element.
     * @param _dateAdapter
     *  date adapter for the date type in the model.
     * @param _displayFormat
     *  from `DL_DATE_TIME_DISPLAY_FORMAT`, which defines the format to use for a valid date/time value.
     * @param _inputFormats
     *  from `DL_DATE_TIME_INPUT_FORMATS`, which defines the input formats that allowed as valid date/time values.
     *  NB: moment is always in strict parse mode for this directive.
     */
    function DlDateTimeInputDirective(_renderer, _elementRef, _dateAdapter, _displayFormat, _inputFormats) {
        var _this = this;
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this._dateAdapter = _dateAdapter;
        this._displayFormat = _displayFormat;
        this._inputFormats = _inputFormats;
        /* tslint:disable:member-ordering */
        this._filterValidator = function (control) {
            // @ts-ignore
            return (_this._inputFilter || (function () { return true; }))(_this._value) ?
                null : { 'dlDateTimeInputFilter': { 'value': control.value } };
        };
        this._inputFilter = function () { return true; };
        this._isValid = true;
        this._parseValidator = function () {
            return _this._isValid ?
                null : { 'dlDateTimeInputParse': { 'text': _this._elementRef.nativeElement.value } };
        };
        this._changed = [];
        this._touched = [];
        this._validator = Validators.compose([this._parseValidator, this._filterValidator]);
        this._onValidatorChange = function () { };
        this._value = undefined;
        /**
         * Emits when a `change` event when date/time is selected or
         * the value of the date/time picker changes.
         **/
        this.dateChange = new EventEmitter();
    }
    DlDateTimeInputDirective_1 = DlDateTimeInputDirective;
    Object.defineProperty(DlDateTimeInputDirective.prototype, "dlDateTimeInputFilter", {
        /**
         * Set a function used to determine whether or not the `value` entered by the user is allowed.
         * @param inputFilterFunction
         *   a function that returns `true` if the `value` entered by the user is allowed, otherwise `false`.
         */
        set: function (inputFilterFunction) {
            this._inputFilter = inputFilterFunction || (function () { return true; });
            this._onValidatorChange();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DlDateTimeInputDirective.prototype, "value", {
        /* tslint:enable:member-ordering */
        /**
         * Returns `D` value of the date/time input or `undefined` | `null` if no value is set.
         **/
        get: function () {
            return this._value;
        },
        /**
         * Set the value of the date/time input to a value of `D` | `undefined` | `null`;
         * @param newValue
         *  the new value of the date/time input
         */
        set: function (newValue) {
            var _this = this;
            if (newValue !== this._value) {
                this._value = newValue;
                this._changed.forEach(function (onChanged) { return onChanged(_this._value); });
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Emit a `change` event when the value of the input changes.
     */
    DlDateTimeInputDirective.prototype._onChange = function () {
        this.dateChange.emit(new DlDateTimeInputChange(this._value));
    };
    /**
     * Format the input text using {@link DL_DATE_TIME_DISPLAY_FORMAT} and mark the control as touched.
     */
    DlDateTimeInputDirective.prototype._onBlur = function () {
        if (this._value) {
            this._setElementValue(this._value);
        }
        this._touched.forEach(function (onTouched) { return onTouched(); });
    };
    /**
     * Parse the user input into a possibly valid date.
     * The model value is not set if the input is NOT one of the {@link DL_DATE_TIME_INPUT_FORMATS}.
     * @param value
     *   Value of the input control.
     */
    DlDateTimeInputDirective.prototype._onInput = function (value) {
        var testDate = value === null || value === undefined || value === ''
            ? undefined
            : moment(value, this._inputFormats, true);
        this._isValid = testDate && testDate.isValid();
        this.value = this._isValid ? this._dateAdapter.fromMilliseconds(testDate.valueOf()) : undefined;
    };
    /**
     * @internal
     */
    DlDateTimeInputDirective.prototype._setElementValue = function (value) {
        if (value !== null && value !== undefined) {
            this._renderer.setProperty(this._elementRef.nativeElement, 'value', moment(value).format(this._displayFormat));
        }
    };
    /**
     * @internal
     */
    DlDateTimeInputDirective.prototype.registerOnChange = function (onChange) {
        this._changed.push(onChange);
    };
    /**
     * @internal
     */
    DlDateTimeInputDirective.prototype.registerOnTouched = function (onTouched) {
        this._touched.push(onTouched);
    };
    /**
     * @internal
     */
    DlDateTimeInputDirective.prototype.registerOnValidatorChange = function (validatorOnChange) {
        this._onValidatorChange = validatorOnChange;
    };
    /**
     * @internal
     */
    DlDateTimeInputDirective.prototype.setDisabledState = function (isDisabled) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
    };
    /**
     * @internal
     */
    DlDateTimeInputDirective.prototype.validate = function (control) {
        return this._validator(control);
    };
    /**
     * @internal
     */
    DlDateTimeInputDirective.prototype.writeValue = function (value) {
        this._isValid = true;
        this.value = value;
        this._setElementValue(value);
    };
    var DlDateTimeInputDirective_1;
    DlDateTimeInputDirective.ctorParameters = function () { return [
        { type: Renderer2 },
        { type: ElementRef },
        { type: DlDateAdapter },
        { type: String, decorators: [{ type: Inject, args: [DL_DATE_TIME_DISPLAY_FORMAT,] }] },
        { type: Array, decorators: [{ type: Inject, args: [DL_DATE_TIME_INPUT_FORMATS,] }] }
    ]; };
    tslib_1.__decorate([
        Output()
    ], DlDateTimeInputDirective.prototype, "dateChange", void 0);
    tslib_1.__decorate([
        Input()
    ], DlDateTimeInputDirective.prototype, "dlDateTimeInputFilter", null);
    tslib_1.__decorate([
        HostListener('change')
    ], DlDateTimeInputDirective.prototype, "_onChange", null);
    tslib_1.__decorate([
        HostListener('blur')
    ], DlDateTimeInputDirective.prototype, "_onBlur", null);
    tslib_1.__decorate([
        HostListener('input', ['$event.target.value'])
    ], DlDateTimeInputDirective.prototype, "_onInput", null);
    DlDateTimeInputDirective = DlDateTimeInputDirective_1 = tslib_1.__decorate([
        Directive({
            selector: 'input[dlDateTimeInput]',
            providers: [
                { provide: NG_VALUE_ACCESSOR, useExisting: DlDateTimeInputDirective_1, multi: true },
                { provide: NG_VALIDATORS, useExisting: DlDateTimeInputDirective_1, multi: true }
            ]
        }),
        tslib_1.__param(3, Inject(DL_DATE_TIME_DISPLAY_FORMAT)),
        tslib_1.__param(4, Inject(DL_DATE_TIME_INPUT_FORMATS))
    ], DlDateTimeInputDirective);
    return DlDateTimeInputDirective;
}());
export { DlDateTimeInputDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGwtZGF0ZS10aW1lLWlucHV0LmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2FuZ3VsYXItYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLyIsInNvdXJjZXMiOlsiZGwtZGF0ZS10aW1lLWlucHV0L2RsLWRhdGUtdGltZS1pbnB1dC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLE9BQU8sRUFBQyxTQUFTLEVBQUUsVUFBVSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsTUFBTSxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQ2xILE9BQU8sRUFHTCxhQUFhLEVBQ2IsaUJBQWlCLEVBSWpCLFVBQVUsR0FDWCxNQUFNLGdCQUFnQixDQUFDO0FBQ3hCLE9BQU8sS0FBSyxPQUFPLE1BQU0sUUFBUSxDQUFDO0FBQ2xDLE9BQU8sRUFBQywyQkFBMkIsRUFBRSwwQkFBMEIsRUFBRSxhQUFhLEVBQUMsTUFBTSxvQkFBb0IsQ0FBQztBQUMxRyxPQUFPLEVBQUMscUJBQXFCLEVBQUMsTUFBTSw2QkFBNkIsQ0FBQztBQUVsRTs7R0FFRztBQUNILElBQU0sTUFBTSxHQUFHLE9BQU8sQ0FBQztBQUV2Qjs7Ozs7R0FLRztBQVFIO0lBMkJFOzs7Ozs7Ozs7Ozs7O09BYUc7SUFDSCxrQ0FDVSxTQUFvQixFQUNwQixXQUF1QixFQUN2QixZQUE4QixFQUNnQixjQUFzQixFQUN2QixhQUF1QjtRQUw5RSxpQkFNSTtRQUxNLGNBQVMsR0FBVCxTQUFTLENBQVc7UUFDcEIsZ0JBQVcsR0FBWCxXQUFXLENBQVk7UUFDdkIsaUJBQVksR0FBWixZQUFZLENBQWtCO1FBQ2dCLG1CQUFjLEdBQWQsY0FBYyxDQUFRO1FBQ3ZCLGtCQUFhLEdBQWIsYUFBYSxDQUFVO1FBNUM5RSxvQ0FBb0M7UUFDNUIscUJBQWdCLEdBQWdCLFVBQUMsT0FBd0I7WUFDL0QsYUFBYTtZQUNiLE9BQU8sQ0FBQyxLQUFJLENBQUMsWUFBWSxJQUFJLENBQUMsY0FBTSxPQUFBLElBQUksRUFBSixDQUFJLENBQUMsQ0FBQyxDQUFDLEtBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDO2dCQUN2RCxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUMsdUJBQXVCLEVBQUUsRUFBQyxPQUFPLEVBQUUsT0FBTyxDQUFDLEtBQUssRUFBQyxFQUFDLENBQUM7UUFDL0QsQ0FBQyxDQUFBO1FBQ08saUJBQVksR0FBbUMsY0FBTSxPQUFBLElBQUksRUFBSixDQUFJLENBQUM7UUFDMUQsYUFBUSxHQUFHLElBQUksQ0FBQztRQUNoQixvQkFBZSxHQUFnQjtZQUNyQyxPQUFPLEtBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDcEIsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFDLHNCQUFzQixFQUFFLEVBQUMsTUFBTSxFQUFFLEtBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxDQUFDLEtBQUssRUFBQyxFQUFDLENBQUM7UUFDcEYsQ0FBQyxDQUFBO1FBQ08sYUFBUSxHQUEyQixFQUFFLENBQUM7UUFDdEMsYUFBUSxHQUFtQixFQUFFLENBQUM7UUFDOUIsZUFBVSxHQUFHLFVBQVUsQ0FBQyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDLENBQUM7UUFDL0UsdUJBQWtCLEdBQWUsY0FBTyxDQUFDLENBQUM7UUFDMUMsV0FBTSxHQUFrQixTQUFTLENBQUM7UUFFMUM7OztZQUdJO1FBRUssZUFBVSxHQUFHLElBQUksWUFBWSxFQUE0QixDQUFDO0lBc0JoRSxDQUFDO2lDQS9DTyx3QkFBd0I7SUF1RG5DLHNCQUFJLDJEQUFxQjtRQU56Qjs7OztXQUlHO2FBRUgsVUFBMEIsbUJBQWlEO1lBQ3pFLElBQUksQ0FBQyxZQUFZLEdBQUcsbUJBQW1CLElBQUksQ0FBQyxjQUFNLE9BQUEsSUFBSSxFQUFKLENBQUksQ0FBQyxDQUFDO1lBQ3hELElBQUksQ0FBQyxrQkFBa0IsRUFBRSxDQUFDO1FBQzVCLENBQUM7OztPQUFBO0lBT0Qsc0JBQUksMkNBQUs7UUFMVCxtQ0FBbUM7UUFFbkM7O1lBRUk7YUFDSjtZQUNFLE9BQU8sSUFBSSxDQUFDLE1BQU0sQ0FBQztRQUNyQixDQUFDO1FBRUQ7Ozs7V0FJRzthQUVILFVBQVUsUUFBOEI7WUFBeEMsaUJBS0M7WUFKQyxJQUFJLFFBQVEsS0FBSyxJQUFJLENBQUMsTUFBTSxFQUFFO2dCQUM1QixJQUFJLENBQUMsTUFBTSxHQUFHLFFBQVEsQ0FBQztnQkFDdkIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsVUFBQSxTQUFTLElBQUksT0FBQSxTQUFTLENBQUMsS0FBSSxDQUFDLE1BQU0sQ0FBQyxFQUF0QixDQUFzQixDQUFDLENBQUM7YUFDNUQ7UUFDSCxDQUFDOzs7T0FiQTtJQWVEOztPQUVHO0lBQ3FCLDRDQUFTLEdBQVQ7UUFDdEIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQztJQUMvRCxDQUFDO0lBRUQ7O09BRUc7SUFDbUIsMENBQU8sR0FBUDtRQUNwQixJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7WUFDZixJQUFJLENBQUMsZ0JBQWdCLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ3BDO1FBQ0QsSUFBSSxDQUFDLFFBQVEsQ0FBQyxPQUFPLENBQUMsVUFBQSxTQUFTLElBQUksT0FBQSxTQUFTLEVBQUUsRUFBWCxDQUFXLENBQUMsQ0FBQztJQUNsRCxDQUFDO0lBRUQ7Ozs7O09BS0c7SUFDNkMsMkNBQVEsR0FBUixVQUFTLEtBQWdDO1FBQ3ZGLElBQU0sUUFBUSxHQUFHLEtBQUssS0FBSyxJQUFJLElBQUksS0FBSyxLQUFLLFNBQVMsSUFBSSxLQUFLLEtBQUssRUFBRTtZQUNwRSxDQUFDLENBQUMsU0FBUztZQUNYLENBQUMsQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxhQUFhLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFFNUMsSUFBSSxDQUFDLFFBQVEsR0FBRyxRQUFRLElBQUksUUFBUSxDQUFDLE9BQU8sRUFBRSxDQUFDO1FBQy9DLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxnQkFBZ0IsQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQyxDQUFDLENBQUMsU0FBUyxDQUFDO0lBQ2xHLENBQUM7SUFFRDs7T0FFRztJQUNLLG1EQUFnQixHQUF4QixVQUF5QixLQUFRO1FBQy9CLElBQUksS0FBSyxLQUFLLElBQUksSUFBSSxLQUFLLEtBQUssU0FBUyxFQUFFO1lBQ3pDLElBQUksQ0FBQyxTQUFTLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsYUFBYSxFQUFFLE9BQU8sRUFBRSxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDO1NBQ2hIO0lBQ0gsQ0FBQztJQUVEOztPQUVHO0lBQ0gsbURBQWdCLEdBQWhCLFVBQWlCLFFBQThCO1FBQzdDLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQy9CLENBQUM7SUFFRDs7T0FFRztJQUNILG9EQUFpQixHQUFqQixVQUFrQixTQUFxQjtRQUNyQyxJQUFJLENBQUMsUUFBUSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNoQyxDQUFDO0lBRUQ7O09BRUc7SUFDSCw0REFBeUIsR0FBekIsVUFBMEIsaUJBQTZCO1FBQ3JELElBQUksQ0FBQyxrQkFBa0IsR0FBRyxpQkFBaUIsQ0FBQztJQUM5QyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxtREFBZ0IsR0FBaEIsVUFBaUIsVUFBbUI7UUFDbEMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxhQUFhLEVBQUUsVUFBVSxFQUFFLFVBQVUsQ0FBQyxDQUFDO0lBQ3JGLENBQUM7SUFFRDs7T0FFRztJQUNILDJDQUFRLEdBQVIsVUFBUyxPQUF3QjtRQUMvQixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDbEMsQ0FBQztJQUVEOztPQUVHO0lBQ0gsNkNBQVUsR0FBVixVQUFXLEtBQVE7UUFDakIsSUFBSSxDQUFDLFFBQVEsR0FBRyxJQUFJLENBQUM7UUFDckIsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLENBQUM7UUFDbkIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLEtBQUssQ0FBQyxDQUFDO0lBQy9CLENBQUM7OztnQkEzSG9CLFNBQVM7Z0JBQ1AsVUFBVTtnQkFDVCxhQUFhOzZDQUNsQyxNQUFNLFNBQUMsMkJBQTJCOzRDQUNsQyxNQUFNLFNBQUMsMEJBQTBCOztJQXJCcEM7UUFEQyxNQUFNLEVBQUU7Z0VBQzBEO0lBOEJuRTtRQURDLEtBQUssRUFBRTt5RUFJUDtJQTJCdUI7UUFBdkIsWUFBWSxDQUFDLFFBQVEsQ0FBQzs2REFFdEI7SUFLcUI7UUFBckIsWUFBWSxDQUFDLE1BQU0sQ0FBQzsyREFLcEI7SUFRK0M7UUFBL0MsWUFBWSxDQUFDLE9BQU8sRUFBRSxDQUFDLHFCQUFxQixDQUFDLENBQUM7NERBTzlDO0lBaEhVLHdCQUF3QjtRQVBwQyxTQUFTLENBQUM7WUFDVCxRQUFRLEVBQUUsd0JBQXdCO1lBQ2xDLFNBQVMsRUFBRTtnQkFDVCxFQUFDLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxXQUFXLEVBQUcsMEJBQXdCLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBQztnQkFDakYsRUFBQyxPQUFPLEVBQUUsYUFBYSxFQUFFLFdBQVcsRUFBRywwQkFBd0IsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFDO2FBQzlFO1NBQ0YsQ0FBQztRQThDRyxtQkFBQSxNQUFNLENBQUMsMkJBQTJCLENBQUMsQ0FBQTtRQUNuQyxtQkFBQSxNQUFNLENBQUMsMEJBQTBCLENBQUMsQ0FBQTtPQTlDMUIsd0JBQXdCLENBc0twQztJQUFELCtCQUFDO0NBQUEsQUF0S0QsSUFzS0M7U0F0S1ksd0JBQXdCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIEV2ZW50RW1pdHRlciwgSG9zdExpc3RlbmVyLCBJbmplY3QsIElucHV0LCBPdXRwdXQsIFJlbmRlcmVyMn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICBBYnN0cmFjdENvbnRyb2wsXG4gIENvbnRyb2xWYWx1ZUFjY2Vzc29yLFxuICBOR19WQUxJREFUT1JTLFxuICBOR19WQUxVRV9BQ0NFU1NPUixcbiAgVmFsaWRhdGlvbkVycm9ycyxcbiAgVmFsaWRhdG9yLFxuICBWYWxpZGF0b3JGbixcbiAgVmFsaWRhdG9ycyxcbn0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuaW1wb3J0ICogYXMgX21vbWVudCBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHtETF9EQVRFX1RJTUVfRElTUExBWV9GT1JNQVQsIERMX0RBVEVfVElNRV9JTlBVVF9GT1JNQVRTLCBEbERhdGVBZGFwdGVyfSBmcm9tICcuLi9jb3JlL3B1YmxpYy1hcGknO1xuaW1wb3J0IHtEbERhdGVUaW1lSW5wdXRDaGFuZ2V9IGZyb20gJy4vZGwtZGF0ZS10aW1lLWlucHV0LWNoYW5nZSc7XG5cbi8qKlxuICogQGludGVybmFsXG4gKi9cbmNvbnN0IG1vbWVudCA9IF9tb21lbnQ7XG5cbi8qKlxuICogIFRoaXMgZGlyZWN0aXZlIGFsbG93cyB0aGUgdXNlciB0byBlbnRlciBkYXRlcywgdXNpbmcgdGhlIGtleWJvYXJkLCBpbnRvIGFuIGlucHV0IGJveCBhbmRcbiAqICBhbmd1bGFyIHdpbGwgdGhlbiBzdG9yZSBhIGRhdGUgdmFsdWUgaW4gdGhlIG1vZGVsLlxuICpcbiAqICBUaGUgaW5wdXQgZm9ybWF0KHMpLCBkaXNwbGF5IGZvcm1hdCwgYW5kIG1vZGVsIGZvcm1hdCBhcmUgaW5kZXBlbmRlbnQgYW5kIGZ1bGx5IGN1c3RvbWl6YWJsZS5cbiAqL1xuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnaW5wdXRbZGxEYXRlVGltZUlucHV0XScsXG4gIHByb3ZpZGVyczogW1xuICAgIHtwcm92aWRlOiBOR19WQUxVRV9BQ0NFU1NPUiwgdXNlRXhpc3Rpbmc6ICBEbERhdGVUaW1lSW5wdXREaXJlY3RpdmUsIG11bHRpOiB0cnVlfSxcbiAgICB7cHJvdmlkZTogTkdfVkFMSURBVE9SUywgdXNlRXhpc3Rpbmc6ICBEbERhdGVUaW1lSW5wdXREaXJlY3RpdmUsIG11bHRpOiB0cnVlfVxuICBdXG59KVxuZXhwb3J0IGNsYXNzIERsRGF0ZVRpbWVJbnB1dERpcmVjdGl2ZTxEPiBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBWYWxpZGF0b3Ige1xuXG4gIC8qIHRzbGludDpkaXNhYmxlOm1lbWJlci1vcmRlcmluZyAqL1xuICBwcml2YXRlIF9maWx0ZXJWYWxpZGF0b3I6IFZhbGlkYXRvckZuID0gKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+IHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcmV0dXJuICh0aGlzLl9pbnB1dEZpbHRlciB8fCAoKCkgPT4gdHJ1ZSkpKHRoaXMuX3ZhbHVlKSA/XG4gICAgICBudWxsIDogeydkbERhdGVUaW1lSW5wdXRGaWx0ZXInOiB7J3ZhbHVlJzogY29udHJvbC52YWx1ZX19O1xuICB9XG4gIHByaXZhdGUgX2lucHV0RmlsdGVyOiAodmFsdWU6IChEIHwgbnVsbCkpID0+IGJvb2xlYW4gPSAoKSA9PiB0cnVlO1xuICBwcml2YXRlIF9pc1ZhbGlkID0gdHJ1ZTtcbiAgcHJpdmF0ZSBfcGFyc2VWYWxpZGF0b3I6IFZhbGlkYXRvckZuID0gKCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsID0+IHtcbiAgICByZXR1cm4gdGhpcy5faXNWYWxpZCA/XG4gICAgICBudWxsIDogeydkbERhdGVUaW1lSW5wdXRQYXJzZSc6IHsndGV4dCc6IHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudC52YWx1ZX19O1xuICB9XG4gIHByaXZhdGUgX2NoYW5nZWQ6ICgodmFsdWU6IEQpID0+IHZvaWQpW10gPSBbXTtcbiAgcHJpdmF0ZSBfdG91Y2hlZDogKCgpID0+IHZvaWQpW10gPSBbXTtcbiAgcHJpdmF0ZSBfdmFsaWRhdG9yID0gVmFsaWRhdG9ycy5jb21wb3NlKFt0aGlzLl9wYXJzZVZhbGlkYXRvciwgdGhpcy5fZmlsdGVyVmFsaWRhdG9yXSk7XG4gIHByaXZhdGUgX29uVmFsaWRhdG9yQ2hhbmdlOiAoKSA9PiB2b2lkID0gKCkgPT4ge307XG4gIHByaXZhdGUgX3ZhbHVlOiBEIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBFbWl0cyB3aGVuIGEgYGNoYW5nZWAgZXZlbnQgd2hlbiBkYXRlL3RpbWUgaXMgc2VsZWN0ZWQgb3JcbiAgICogdGhlIHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgcGlja2VyIGNoYW5nZXMuXG4gICAqKi9cbiAgQE91dHB1dCgpXG4gIHJlYWRvbmx5IGRhdGVDaGFuZ2UgPSBuZXcgRXZlbnRFbWl0dGVyPERsRGF0ZVRpbWVJbnB1dENoYW5nZTxEPj4oKTtcblxuICAvKipcbiAgICogQ29uc3RydWN0cyBhIG5ldyBpbnN0YW5jZSBvZiB0aGlzIGRpcmVjdGl2ZS5cbiAgICogQHBhcmFtIF9yZW5kZXJlclxuICAgKiAgcmVmZXJlbmNlIHRvIHRoZSByZW5kZXJlci5cbiAgICogQHBhcmFtIF9lbGVtZW50UmVmXG4gICAqICByZWZlcmVuY2UgdG8gdGhpcyBlbGVtZW50LlxuICAgKiBAcGFyYW0gX2RhdGVBZGFwdGVyXG4gICAqICBkYXRlIGFkYXB0ZXIgZm9yIHRoZSBkYXRlIHR5cGUgaW4gdGhlIG1vZGVsLlxuICAgKiBAcGFyYW0gX2Rpc3BsYXlGb3JtYXRcbiAgICogIGZyb20gYERMX0RBVEVfVElNRV9ESVNQTEFZX0ZPUk1BVGAsIHdoaWNoIGRlZmluZXMgdGhlIGZvcm1hdCB0byB1c2UgZm9yIGEgdmFsaWQgZGF0ZS90aW1lIHZhbHVlLlxuICAgKiBAcGFyYW0gX2lucHV0Rm9ybWF0c1xuICAgKiAgZnJvbSBgRExfREFURV9USU1FX0lOUFVUX0ZPUk1BVFNgLCB3aGljaCBkZWZpbmVzIHRoZSBpbnB1dCBmb3JtYXRzIHRoYXQgYWxsb3dlZCBhcyB2YWxpZCBkYXRlL3RpbWUgdmFsdWVzLlxuICAgKiAgTkI6IG1vbWVudCBpcyBhbHdheXMgaW4gc3RyaWN0IHBhcnNlIG1vZGUgZm9yIHRoaXMgZGlyZWN0aXZlLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfcmVuZGVyZXI6IFJlbmRlcmVyMixcbiAgICBwcml2YXRlIF9lbGVtZW50UmVmOiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgX2RhdGVBZGFwdGVyOiBEbERhdGVBZGFwdGVyPEQ+LFxuICAgIEBJbmplY3QoRExfREFURV9USU1FX0RJU1BMQVlfRk9STUFUKSBwcml2YXRlIHJlYWRvbmx5IF9kaXNwbGF5Rm9ybWF0OiBzdHJpbmcsXG4gICAgQEluamVjdChETF9EQVRFX1RJTUVfSU5QVVRfRk9STUFUUykgcHJpdmF0ZSByZWFkb25seSBfaW5wdXRGb3JtYXRzOiBzdHJpbmdbXVxuICApIHt9XG5cbiAgLyoqXG4gICAqIFNldCBhIGZ1bmN0aW9uIHVzZWQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IHRoZSBgdmFsdWVgIGVudGVyZWQgYnkgdGhlIHVzZXIgaXMgYWxsb3dlZC5cbiAgICogQHBhcmFtIGlucHV0RmlsdGVyRnVuY3Rpb25cbiAgICogICBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgZW50ZXJlZCBieSB0aGUgdXNlciBpcyBhbGxvd2VkLCBvdGhlcndpc2UgYGZhbHNlYC5cbiAgICovXG4gIEBJbnB1dCgpXG4gIHNldCBkbERhdGVUaW1lSW5wdXRGaWx0ZXIoaW5wdXRGaWx0ZXJGdW5jdGlvbjogKHZhbHVlOiBEIHwgbnVsbCkgPT4gYm9vbGVhbikge1xuICAgIHRoaXMuX2lucHV0RmlsdGVyID0gaW5wdXRGaWx0ZXJGdW5jdGlvbiB8fCAoKCkgPT4gdHJ1ZSk7XG4gICAgdGhpcy5fb25WYWxpZGF0b3JDaGFuZ2UoKTtcbiAgfVxuXG4gIC8qIHRzbGludDplbmFibGU6bWVtYmVyLW9yZGVyaW5nICovXG5cbiAgLyoqXG4gICAqIFJldHVybnMgYERgIHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgaW5wdXQgb3IgYHVuZGVmaW5lZGAgfCBgbnVsbGAgaWYgbm8gdmFsdWUgaXMgc2V0LlxuICAgKiovXG4gIGdldCB2YWx1ZSgpOiBEIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogU2V0IHRoZSB2YWx1ZSBvZiB0aGUgZGF0ZS90aW1lIGlucHV0IHRvIGEgdmFsdWUgb2YgYERgIHwgYHVuZGVmaW5lZGAgfCBgbnVsbGA7XG4gICAqIEBwYXJhbSBuZXdWYWx1ZVxuICAgKiAgdGhlIG5ldyB2YWx1ZSBvZiB0aGUgZGF0ZS90aW1lIGlucHV0XG4gICAqL1xuXG4gIHNldCB2YWx1ZShuZXdWYWx1ZTogRCB8IG51bGwgfCB1bmRlZmluZWQpIHtcbiAgICBpZiAobmV3VmFsdWUgIT09IHRoaXMuX3ZhbHVlKSB7XG4gICAgICB0aGlzLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgICAgdGhpcy5fY2hhbmdlZC5mb3JFYWNoKG9uQ2hhbmdlZCA9PiBvbkNoYW5nZWQodGhpcy5fdmFsdWUpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW1pdCBhIGBjaGFuZ2VgIGV2ZW50IHdoZW4gdGhlIHZhbHVlIG9mIHRoZSBpbnB1dCBjaGFuZ2VzLlxuICAgKi9cbiAgQEhvc3RMaXN0ZW5lcignY2hhbmdlJykgX29uQ2hhbmdlKCkge1xuICAgIHRoaXMuZGF0ZUNoYW5nZS5lbWl0KG5ldyBEbERhdGVUaW1lSW5wdXRDaGFuZ2UodGhpcy5fdmFsdWUpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JtYXQgdGhlIGlucHV0IHRleHQgdXNpbmcge0BsaW5rIERMX0RBVEVfVElNRV9ESVNQTEFZX0ZPUk1BVH0gYW5kIG1hcmsgdGhlIGNvbnRyb2wgYXMgdG91Y2hlZC5cbiAgICovXG4gIEBIb3N0TGlzdGVuZXIoJ2JsdXInKSBfb25CbHVyKCkge1xuICAgIGlmICh0aGlzLl92YWx1ZSkge1xuICAgICAgdGhpcy5fc2V0RWxlbWVudFZhbHVlKHRoaXMuX3ZhbHVlKTtcbiAgICB9XG4gICAgdGhpcy5fdG91Y2hlZC5mb3JFYWNoKG9uVG91Y2hlZCA9PiBvblRvdWNoZWQoKSk7XG4gIH1cblxuICAvKipcbiAgICogUGFyc2UgdGhlIHVzZXIgaW5wdXQgaW50byBhIHBvc3NpYmx5IHZhbGlkIGRhdGUuXG4gICAqIFRoZSBtb2RlbCB2YWx1ZSBpcyBub3Qgc2V0IGlmIHRoZSBpbnB1dCBpcyBOT1Qgb25lIG9mIHRoZSB7QGxpbmsgRExfREFURV9USU1FX0lOUFVUX0ZPUk1BVFN9LlxuICAgKiBAcGFyYW0gdmFsdWVcbiAgICogICBWYWx1ZSBvZiB0aGUgaW5wdXQgY29udHJvbC5cbiAgICovXG4gIEBIb3N0TGlzdGVuZXIoJ2lucHV0JywgWyckZXZlbnQudGFyZ2V0LnZhbHVlJ10pIF9vbklucHV0KHZhbHVlOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkKTogdm9pZCB7XG4gICAgY29uc3QgdGVzdERhdGUgPSB2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSAnJ1xuICAgICAgPyB1bmRlZmluZWRcbiAgICAgIDogbW9tZW50KHZhbHVlLCB0aGlzLl9pbnB1dEZvcm1hdHMsIHRydWUpO1xuXG4gICAgdGhpcy5faXNWYWxpZCA9IHRlc3REYXRlICYmIHRlc3REYXRlLmlzVmFsaWQoKTtcbiAgICB0aGlzLnZhbHVlID0gdGhpcy5faXNWYWxpZCA/IHRoaXMuX2RhdGVBZGFwdGVyLmZyb21NaWxsaXNlY29uZHModGVzdERhdGUudmFsdWVPZigpKSA6IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHByaXZhdGUgX3NldEVsZW1lbnRWYWx1ZSh2YWx1ZTogRCkge1xuICAgIGlmICh2YWx1ZSAhPT0gbnVsbCAmJiB2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aGlzLl9yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICd2YWx1ZScsIG1vbWVudCh2YWx1ZSkuZm9ybWF0KHRoaXMuX2Rpc3BsYXlGb3JtYXQpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICByZWdpc3Rlck9uQ2hhbmdlKG9uQ2hhbmdlOiAodmFsdWU6IGFueSkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMuX2NoYW5nZWQucHVzaChvbkNoYW5nZSk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICByZWdpc3Rlck9uVG91Y2hlZChvblRvdWNoZWQ6ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLl90b3VjaGVkLnB1c2gob25Ub3VjaGVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlZ2lzdGVyT25WYWxpZGF0b3JDaGFuZ2UodmFsaWRhdG9yT25DaGFuZ2U6ICgpID0+IHZvaWQpOiB2b2lkIHtcbiAgICB0aGlzLl9vblZhbGlkYXRvckNoYW5nZSA9IHZhbGlkYXRvck9uQ2hhbmdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgc2V0RGlzYWJsZWRTdGF0ZShpc0Rpc2FibGVkOiBib29sZWFuKTogdm9pZCB7XG4gICAgdGhpcy5fcmVuZGVyZXIuc2V0UHJvcGVydHkodGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LCAnZGlzYWJsZWQnLCBpc0Rpc2FibGVkKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHZhbGlkYXRlKGNvbnRyb2w6IEFic3RyYWN0Q29udHJvbCk6IFZhbGlkYXRpb25FcnJvcnMgfCBudWxsIHtcbiAgICByZXR1cm4gdGhpcy5fdmFsaWRhdG9yKGNvbnRyb2wpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgd3JpdGVWYWx1ZSh2YWx1ZTogRCk6IHZvaWQge1xuICAgIHRoaXMuX2lzVmFsaWQgPSB0cnVlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICB0aGlzLl9zZXRFbGVtZW50VmFsdWUodmFsdWUpO1xuICB9XG59XG4iXX0=