(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('moment'), require('@angular/core'), require('@angular/forms'), require('@angular/common'), require('rxjs/operators')) :
    typeof define === 'function' && define.amd ? define('angular-bootstrap-datetimepicker', ['exports', 'moment', '@angular/core', '@angular/forms', '@angular/common', 'rxjs/operators'], factory) :
    (global = global || self, factory(global['angular-bootstrap-datetimepicker'] = {}, global.moment, global.ng.core, global.ng.forms, global.ng.common, global.rxjs.operators));
}(this, (function (exports, _moment, core, forms, common, operators) { 'use strict';

    var _moment__default = 'default' in _moment ? _moment['default'] : _moment;

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    function __rest(s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }

    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }

    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    }

    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    function __exportStar(m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }

    function __values(o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    }

    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    }

    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }

    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    };

    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }

    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    }

    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }

    function __asyncValues(o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
    }

    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    function __importStar(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
        result.default = mod;
        return result;
    }

    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }

    /**
     * Determines the model type of the Date/Time picker another type.
     */
    var DlDateAdapter = /** @class */ (function () {
        function DlDateAdapter() {
        }
        return DlDateAdapter;
    }());

    /**
     * Work around for moment namespace conflict when used with webpack and rollup.
     * See https://github.com/dherges/ng-packagr/issues/163
     *
     * Depending on whether rollup is used, moment needs to be imported differently.
     * Since Moment.js doesn't have a default export, we normally need to import using
     * the `* as`syntax.
     *
     * rollup creates a synthetic default module and we thus need to import it using
     * the `default as` syntax.
     *
     * @internal
     **/
    var moment = _moment;
    /**
     * Adapts `moment` to be usable as a date by date/time components that work with dates.
     **/
    var DlDateAdapterMoment = /** @class */ (function (_super) {
        __extends(DlDateAdapterMoment, _super);
        function DlDateAdapterMoment() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Create a new instance of a `moment` type from milliseconds.
         * @param milliseconds
         *  a time value as milliseconds (local time zone)
         * @returns
         *  an instance of `moment` for the specified moment in time.
         */
        DlDateAdapterMoment.prototype.fromMilliseconds = function (milliseconds) {
            return moment(milliseconds);
        };
        /**
         * Returns a moment in time value as milliseconds (local time zone).
         * @param value
         *  a moment or `null`.
         * @returns
         *  a `moment.valueOf()` result for the specified `moment` or `null`
         */
        DlDateAdapterMoment.prototype.toMilliseconds = function (value) {
            return (value) ? value.valueOf() : undefined;
        };
        return DlDateAdapterMoment;
    }(DlDateAdapter));

    /**
     * Adapts `Date` to be usable as a date by date/time components that work with dates.
     **/
    var DlDateAdapterNative = /** @class */ (function (_super) {
        __extends(DlDateAdapterNative, _super);
        function DlDateAdapterNative() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Create a new instance of a `moment` type from milliseconds.
         * @param milliseconds
         *  a time value as milliseconds (local time zone)
         * @returns
         *  an instance of `moment` for the specified moment in time.
         */
        DlDateAdapterNative.prototype.fromMilliseconds = function (milliseconds) {
            return new Date(milliseconds);
        };
        /**
         * Returns a moment in time value as milliseconds (local time zone).
         * @param value
         *  a Date or null.
         * @returns
         *  a `value.getTime()` result for the specified `Date` or `null`.
         */
        DlDateAdapterNative.prototype.toMilliseconds = function (value) {
            return (value) ? value.getTime() : undefined;
        };
        return DlDateAdapterNative;
    }(DlDateAdapter));

    /**
     * Adapts `number` to be usable as a date by date/time components that work with dates.
     * No op adapter.
     **/
    var DlDateAdapterNumber = /** @class */ (function (_super) {
        __extends(DlDateAdapterNumber, _super);
        function DlDateAdapterNumber() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Returns the specified number.
         * @param milliseconds
         *  a moment time time.
         * @returns
         *  the specified moment in time.
         */
        DlDateAdapterNumber.prototype.fromMilliseconds = function (milliseconds) {
            return milliseconds;
        };
        /**
         * Returns the specified number.
         * @param value
         *  a moment time time or `null`
         * @returns
         *  the specified moment in time or `null`
         */
        DlDateAdapterNumber.prototype.toMilliseconds = function (value) {
            return value;
        };
        return DlDateAdapterNumber;
    }(DlDateAdapter));

    /**
     * @internal
     */
    var moment$1 = _moment;
    /* istanbul ignore if */
    if ('default' in _moment) {
        moment$1 = _moment__default;
    }
    /**
     * InjectionToken for string dates that can be used to override default model format.
     **/
    var DL_DATE_TIME_DISPLAY_FORMAT = new core.InjectionToken('DL_DATE_TIME_DISPLAY_FORMAT');
    /**
     * `Moment`'s long date format `lll` used as the default output format
     * for string date's
     */
    var DL_DATE_TIME_DISPLAY_FORMAT_DEFAULT = moment$1.localeData().longDateFormat('lll');
    /**
     * InjectionToken for string dates that can be used to override default input formats.
     **/
    var DL_DATE_TIME_INPUT_FORMATS = new core.InjectionToken('DL_DATE__TIME_INPUT_FORMATS');
    /**
     *  Default input format's used by `DlDateAdapterString`
     */
    var DL_DATE_TIME_INPUT_FORMATS_DEFAULT = [
        'YYYY-MM-DDTHH:mm',
        'YYYY-MM-DDTHH:mm:ss',
        'YYYY-MM-DDTHH:mm:ss.SSS',
        'YYYY-MM-DD',
        'M/D/YYYY h:m:s A',
        'M/D/YYYY h:m A',
        'M/D/YYYY h:m A',
        'M/D/YYYY',
        'M/D/YY h:m:s A',
        'M/D/YY h:m A',
        'M/D/YY h A',
        'M/D/YY',
        DL_DATE_TIME_DISPLAY_FORMAT_DEFAULT,
        moment$1.ISO_8601,
    ];
    /**
     * InjectionToken for string dates that can be used to override default model format.
     **/
    var DL_DATE_TIME_MODEL_FORMAT = new core.InjectionToken('DL_DATE_TIME_MODEL_FORMAT');
    /**
     *  Default model format (ISO 8601)`
     */
    var DL_DATE_TIME_MODEL_FORMAT_DEFAULT = 'YYYY-MM-DDTHH:mm:ss.SSSZ';

    /**
     * Work around for moment namespace conflict when used with webpack and rollup.
     * See https://github.com/dherges/ng-packagr/issues/163
     *
     * Depending on whether rollup is used, moment needs to be imported differently.
     * Since Moment.js doesn't have a default export, we normally need to import using
     * the `* as`syntax.
     *
     * rollup creates a synthetic default module and we thus need to import it using
     * the `default as` syntax.
     *
     * @internal
     *
     **/
    var moment$2 = _moment;
    /**
     * Adapts `string` to be usable as a date by date/time components that work with dates.
     **/
    var DlDateAdapterString = /** @class */ (function (_super) {
        __extends(DlDateAdapterString, _super);
        /**
         *  Constructs a new instance of this class.
         *
         * @param inputFormats
         *  see {@link DL_DATE_TIME_INPUT_FORMATS}
         * @param modelFormat
         *  see {@link DL_DATE_TIME_MODEL_FORMAT}
         */
        function DlDateAdapterString(inputFormats, modelFormat) {
            var _this = _super.call(this) || this;
            _this.inputFormats = inputFormats;
            _this.modelFormat = modelFormat;
            return _this;
        }
        /**
         * Returns the specified number.
         * @param milliseconds
         *  a moment time time.
         * @returns
         *  the specified moment in time.
         */
        DlDateAdapterString.prototype.fromMilliseconds = function (milliseconds) {
            return moment$2(milliseconds).format(this.modelFormat);
        };
        /**
         * Returns the specified number.
         * @param value
         *  a moment time time or `null`
         * @returns
         *  the milliseconds for the specified value or `null`
         *  `null` is returned when value is not a valid input date string
         */
        DlDateAdapterString.prototype.toMilliseconds = function (value) {
            if (value !== undefined && value !== null) {
                var newMoment = moment$2(value, this.inputFormats, true);
                return newMoment.isValid() ? newMoment.valueOf() : undefined;
            }
        };
        DlDateAdapterString = __decorate([
            __param(0, core.Inject(DL_DATE_TIME_INPUT_FORMATS)),
            __param(1, core.Inject(DL_DATE_TIME_MODEL_FORMAT))
        ], DlDateAdapterString);
        return DlDateAdapterString;
    }(DlDateAdapter));

    var ɵ0 = DL_DATE_TIME_DISPLAY_FORMAT_DEFAULT, ɵ1 = DL_DATE_TIME_INPUT_FORMATS_DEFAULT, ɵ2 = DL_DATE_TIME_MODEL_FORMAT_DEFAULT;
    /**
     * Import this module to supply your own `DateAdapter` provider.
     * @internal
     **/
    var DlDateTimeCoreModule = /** @class */ (function () {
        function DlDateTimeCoreModule() {
        }
        DlDateTimeCoreModule = __decorate([
            core.NgModule({
                providers: [
                    { provide: DL_DATE_TIME_DISPLAY_FORMAT, useValue: ɵ0 },
                    { provide: DL_DATE_TIME_INPUT_FORMATS, useValue: ɵ1 },
                    { provide: DL_DATE_TIME_MODEL_FORMAT, useValue: ɵ2 }
                ]
            })
        ], DlDateTimeCoreModule);
        return DlDateTimeCoreModule;
    }());
    /**
     * Import this module to store `milliseconds` in the model.
     * @internal
     */
    var DlDateTimeNumberModule = /** @class */ (function () {
        function DlDateTimeNumberModule() {
        }
        DlDateTimeNumberModule = __decorate([
            core.NgModule({
                imports: [DlDateTimeCoreModule],
                providers: [
                    { provide: DlDateAdapter, useClass: DlDateAdapterNumber }
                ],
                exports: [DlDateTimeCoreModule]
            })
        ], DlDateTimeNumberModule);
        return DlDateTimeNumberModule;
    }());
    /**
     * Import this module to store a native JavaScript `Date` in the model.
     * @internal
     */
    var DlDateTimeDateModule = /** @class */ (function () {
        function DlDateTimeDateModule() {
        }
        DlDateTimeDateModule = __decorate([
            core.NgModule({
                imports: [DlDateTimeCoreModule],
                providers: [
                    { provide: DlDateAdapter, useClass: DlDateAdapterNative }
                ],
            })
        ], DlDateTimeDateModule);
        return DlDateTimeDateModule;
    }());
    /**
     * Import this module to store a `moment` in the model.
     * @internal
     */
    var DlDateTimeMomentModule = /** @class */ (function () {
        function DlDateTimeMomentModule() {
        }
        DlDateTimeMomentModule = __decorate([
            core.NgModule({
                imports: [DlDateTimeCoreModule],
                providers: [
                    { provide: DlDateAdapter, useClass: DlDateAdapterMoment }
                ],
            })
        ], DlDateTimeMomentModule);
        return DlDateTimeMomentModule;
    }());
    var ɵ3 = DL_DATE_TIME_INPUT_FORMATS_DEFAULT, ɵ4 = DL_DATE_TIME_DISPLAY_FORMAT_DEFAULT;
    /**
     * Import this module to store a `string` in the model.
     * @internal
     */
    var DlDateTimeStringModule = /** @class */ (function () {
        function DlDateTimeStringModule() {
        }
        DlDateTimeStringModule = __decorate([
            core.NgModule({
                imports: [DlDateTimeCoreModule],
                providers: [
                    { provide: DL_DATE_TIME_INPUT_FORMATS, useValue: ɵ3 },
                    { provide: DL_DATE_TIME_MODEL_FORMAT, useValue: ɵ4 },
                    { provide: DlDateAdapter, useClass: DlDateAdapterString }
                ],
            })
        ], DlDateTimeStringModule);
        return DlDateTimeStringModule;
    }());

    /**
     * @license
     * Copyright 2013-present Dale Lotts All Rights Reserved.
     * http://www.dalelotts.com
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://github.com/dalelotts/angular-bootstrap-datetimepicker/blob/master/LICENSE
     */

    /**
     * @license
     * Copyright 2013-present Dale Lotts All Rights Reserved.
     * http://www.dalelotts.com
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://github.com/dalelotts/angular-bootstrap-datetimepicker/blob/master/LICENSE
     */
    /**
     * Emitted when the value of a date/time input changes.
     */
    var DlDateTimeInputChange = /** @class */ (function () {
        /**
         * Constructs a new instance.
         * @param newValue
         *  the new value of the date/time picker.
         */
        function DlDateTimeInputChange(newValue) {
            this._value = newValue;
        }
        Object.defineProperty(DlDateTimeInputChange.prototype, "value", {
            /**
             * Get the new value of the date/time picker.
             * @returns the new value or null.
             */
            get: function () {
                return this._value;
            },
            enumerable: true,
            configurable: true
        });
        return DlDateTimeInputChange;
    }());

    /**
     * @internal
     */
    var moment$3 = _moment;
    /**
     *  This directive allows the user to enter dates, using the keyboard, into an input box and
     *  angular will then store a date value in the model.
     *
     *  The input format(s), display format, and model format are independent and fully customizable.
     */
    var DlDateTimeInputDirective = /** @class */ (function () {
        /**
         * Constructs a new instance of this directive.
         * @param _renderer
         *  reference to the renderer.
         * @param _elementRef
         *  reference to this element.
         * @param _dateAdapter
         *  date adapter for the date type in the model.
         * @param _displayFormat
         *  from `DL_DATE_TIME_DISPLAY_FORMAT`, which defines the format to use for a valid date/time value.
         * @param _inputFormats
         *  from `DL_DATE_TIME_INPUT_FORMATS`, which defines the input formats that allowed as valid date/time values.
         *  NB: moment is always in strict parse mode for this directive.
         */
        function DlDateTimeInputDirective(_renderer, _elementRef, _dateAdapter, _displayFormat, _inputFormats) {
            var _this = this;
            this._renderer = _renderer;
            this._elementRef = _elementRef;
            this._dateAdapter = _dateAdapter;
            this._displayFormat = _displayFormat;
            this._inputFormats = _inputFormats;
            /* tslint:disable:member-ordering */
            this._filterValidator = function (control) {
                // @ts-ignore
                return (_this._inputFilter || (function () { return true; }))(_this._value) ?
                    null : { 'dlDateTimeInputFilter': { 'value': control.value } };
            };
            this._inputFilter = function () { return true; };
            this._isValid = true;
            this._parseValidator = function () {
                return _this._isValid ?
                    null : { 'dlDateTimeInputParse': { 'text': _this._elementRef.nativeElement.value } };
            };
            this._changed = [];
            this._touched = [];
            this._validator = forms.Validators.compose([this._parseValidator, this._filterValidator]);
            this._onValidatorChange = function () { };
            this._value = undefined;
            /**
             * Emits when a `change` event when date/time is selected or
             * the value of the date/time picker changes.
             **/
            this.dateChange = new core.EventEmitter();
        }
        DlDateTimeInputDirective_1 = DlDateTimeInputDirective;
        Object.defineProperty(DlDateTimeInputDirective.prototype, "dlDateTimeInputFilter", {
            /**
             * Set a function used to determine whether or not the `value` entered by the user is allowed.
             * @param inputFilterFunction
             *   a function that returns `true` if the `value` entered by the user is allowed, otherwise `false`.
             */
            set: function (inputFilterFunction) {
                this._inputFilter = inputFilterFunction || (function () { return true; });
                this._onValidatorChange();
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DlDateTimeInputDirective.prototype, "value", {
            /* tslint:enable:member-ordering */
            /**
             * Returns `D` value of the date/time input or `undefined` | `null` if no value is set.
             **/
            get: function () {
                return this._value;
            },
            /**
             * Set the value of the date/time input to a value of `D` | `undefined` | `null`;
             * @param newValue
             *  the new value of the date/time input
             */
            set: function (newValue) {
                var _this = this;
                if (newValue !== this._value) {
                    this._value = newValue;
                    this._changed.forEach(function (onChanged) { return onChanged(_this._value); });
                }
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Emit a `change` event when the value of the input changes.
         */
        DlDateTimeInputDirective.prototype._onChange = function () {
            this.dateChange.emit(new DlDateTimeInputChange(this._value));
        };
        /**
         * Format the input text using {@link DL_DATE_TIME_DISPLAY_FORMAT} and mark the control as touched.
         */
        DlDateTimeInputDirective.prototype._onBlur = function () {
            if (this._value) {
                this._setElementValue(this._value);
            }
            this._touched.forEach(function (onTouched) { return onTouched(); });
        };
        /**
         * Parse the user input into a possibly valid date.
         * The model value is not set if the input is NOT one of the {@link DL_DATE_TIME_INPUT_FORMATS}.
         * @param value
         *   Value of the input control.
         */
        DlDateTimeInputDirective.prototype._onInput = function (value) {
            var testDate = value === null || value === undefined || value === ''
                ? undefined
                : moment$3(value, this._inputFormats, true);
            this._isValid = testDate && testDate.isValid();
            this.value = this._isValid ? this._dateAdapter.fromMilliseconds(testDate.valueOf()) : undefined;
        };
        /**
         * @internal
         */
        DlDateTimeInputDirective.prototype._setElementValue = function (value) {
            if (value !== null && value !== undefined) {
                this._renderer.setProperty(this._elementRef.nativeElement, 'value', moment$3(value).format(this._displayFormat));
            }
        };
        /**
         * @internal
         */
        DlDateTimeInputDirective.prototype.registerOnChange = function (onChange) {
            this._changed.push(onChange);
        };
        /**
         * @internal
         */
        DlDateTimeInputDirective.prototype.registerOnTouched = function (onTouched) {
            this._touched.push(onTouched);
        };
        /**
         * @internal
         */
        DlDateTimeInputDirective.prototype.registerOnValidatorChange = function (validatorOnChange) {
            this._onValidatorChange = validatorOnChange;
        };
        /**
         * @internal
         */
        DlDateTimeInputDirective.prototype.setDisabledState = function (isDisabled) {
            this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
        };
        /**
         * @internal
         */
        DlDateTimeInputDirective.prototype.validate = function (control) {
            return this._validator(control);
        };
        /**
         * @internal
         */
        DlDateTimeInputDirective.prototype.writeValue = function (value) {
            this._isValid = true;
            this.value = value;
            this._setElementValue(value);
        };
        var DlDateTimeInputDirective_1;
        DlDateTimeInputDirective.ctorParameters = function () { return [
            { type: core.Renderer2 },
            { type: core.ElementRef },
            { type: DlDateAdapter },
            { type: String, decorators: [{ type: core.Inject, args: [DL_DATE_TIME_DISPLAY_FORMAT,] }] },
            { type: Array, decorators: [{ type: core.Inject, args: [DL_DATE_TIME_INPUT_FORMATS,] }] }
        ]; };
        __decorate([
            core.Output()
        ], DlDateTimeInputDirective.prototype, "dateChange", void 0);
        __decorate([
            core.Input()
        ], DlDateTimeInputDirective.prototype, "dlDateTimeInputFilter", null);
        __decorate([
            core.HostListener('change')
        ], DlDateTimeInputDirective.prototype, "_onChange", null);
        __decorate([
            core.HostListener('blur')
        ], DlDateTimeInputDirective.prototype, "_onBlur", null);
        __decorate([
            core.HostListener('input', ['$event.target.value'])
        ], DlDateTimeInputDirective.prototype, "_onInput", null);
        DlDateTimeInputDirective = DlDateTimeInputDirective_1 = __decorate([
            core.Directive({
                selector: 'input[dlDateTimeInput]',
                providers: [
                    { provide: forms.NG_VALUE_ACCESSOR, useExisting: DlDateTimeInputDirective_1, multi: true },
                    { provide: forms.NG_VALIDATORS, useExisting: DlDateTimeInputDirective_1, multi: true }
                ]
            }),
            __param(3, core.Inject(DL_DATE_TIME_DISPLAY_FORMAT)),
            __param(4, core.Inject(DL_DATE_TIME_INPUT_FORMATS))
        ], DlDateTimeInputDirective);
        return DlDateTimeInputDirective;
    }());

    /**
     * @license
     * Copyright 2013-present Dale Lotts All Rights Reserved.
     * http://www.dalelotts.com
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://github.com/dalelotts/angular-bootstrap-datetimepicker/blob/master/LICENSE
     */
    /**
     * Import this module to allow date/time input.
     * @internal
     **/
    var DlDateTimeInputModule = /** @class */ (function () {
        function DlDateTimeInputModule() {
        }
        DlDateTimeInputModule = __decorate([
            core.NgModule({
                declarations: [DlDateTimeInputDirective],
                imports: [common.CommonModule],
                exports: [DlDateTimeInputDirective],
            })
        ], DlDateTimeInputModule);
        return DlDateTimeInputModule;
    }());

    /**
     * @license
     * Copyright 2013-present Dale Lotts All Rights Reserved.
     * http://www.dalelotts.com
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://github.com/dalelotts/angular-bootstrap-datetimepicker/blob/master/LICENSE
     */

    /**
     * @license
     * Copyright 2013-present Dale Lotts All Rights Reserved.
     * http://www.dalelotts.com
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://github.com/dalelotts/angular-bootstrap-datetimepicker/blob/master/LICENSE
     */
    /**
     * Emitted when the value of a date/time picker changes.
     */
    var DlDateTimePickerChange = /** @class */ (function () {
        /**
         * Constructs a new instance.
         * @param newValue
         *  the new value of the date/time picker.
         */
        function DlDateTimePickerChange(newValue) {
            this._value = newValue;
        }
        Object.defineProperty(DlDateTimePickerChange.prototype, "value", {
            /**
             * Get the new value of the date/time picker.
             * @returns the new value or null.
             */
            get: function () {
                return this._value;
            },
            enumerable: true,
            configurable: true
        });
        return DlDateTimePickerChange;
    }());

    /**
     * @license
     * Copyright 2013-present Dale Lotts All Rights Reserved.
     * http://www.dalelotts.com
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://github.com/dalelotts/angular-bootstrap-datetimepicker/blob/master/LICENSE
     */
    /**
     * Work around for moment namespace conflict when used with webpack and rollup.
     * See https://github.com/dherges/ng-packagr/issues/163
     *
     * Depending on whether rollup is used, moment needs to be imported differently.
     * Since Moment.js doesn't have a default export, we normally need to import using
     * the `* as`syntax.
     *
     * rollup creates a synthetic default module and we thus need to import it using
     * the `default as` syntax.
     *
     * @internal
     **/
    var moment$4 = _moment;
    /**
     * Default implementation for the `day` view.
     */
    var DlDayModelProvider = /** @class */ (function () {
        function DlDayModelProvider() {
        }
        /**
         * Receives input changes detected by Angular.
         *
         * @param changes
         *  the input changes detected by Angular.
         */
        DlDayModelProvider.prototype.onChanges = function (
        // @ts-ignore
        changes) { };
        /**
         * Returns the `day` model for the specified moment in `local` time with the
         * `active` day set to the first day of the month.
         *
         * The `day` model represents a month (42 days) as six rows with seven columns
         * and each cell representing one-day increments.
         *
         * The `day` always starts at midnight.
         *
         * Each cell represents a one-day increment at midnight.
         *
         * @param milliseconds
         *  the moment in time from which the minute model will be created.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  the model representing the specified moment in time.
         */
        DlDayModelProvider.prototype.getModel = function (milliseconds, selectedMilliseconds) {
            var startOfMonth = moment$4(milliseconds).startOf('month');
            var endOfMonth = moment$4(milliseconds).endOf('month');
            var startOfView = moment$4(startOfMonth).subtract(Math.abs(startOfMonth.weekday()), 'days');
            var rowNumbers = [0, 1, 2, 3, 4, 5];
            var columnNumbers = [0, 1, 2, 3, 4, 5, 6];
            var previousMonth = moment$4(startOfMonth).subtract(1, 'month');
            var nextMonth = moment$4(startOfMonth).add(1, 'month');
            var activeValue = moment$4(milliseconds).startOf('day').valueOf();
            var selectedValue = selectedMilliseconds === null || selectedMilliseconds === undefined
                ? selectedMilliseconds
                : moment$4(selectedMilliseconds).startOf('day').valueOf();
            return {
                viewName: 'day',
                viewLabel: startOfMonth.format('MMM YYYY'),
                activeDate: activeValue,
                leftButton: {
                    value: previousMonth.valueOf(),
                    ariaLabel: "Go to " + previousMonth.format('MMM YYYY'),
                    classes: {},
                },
                upButton: {
                    value: startOfMonth.valueOf(),
                    ariaLabel: "Go to month view",
                    classes: {},
                },
                rightButton: {
                    value: nextMonth.valueOf(),
                    ariaLabel: "Go to " + nextMonth.format('MMM YYYY'),
                    classes: {},
                },
                rowLabels: columnNumbers.map(function (column) { return moment$4().weekday(column).format('dd'); }),
                rows: rowNumbers.map(rowOfDays)
            };
            function rowOfDays(rowNumber) {
                var currentMoment = moment$4();
                var cells = columnNumbers.map(function (columnNumber) {
                    var dayMoment = moment$4(startOfView).add((rowNumber * columnNumbers.length) + columnNumber, 'days');
                    return {
                        display: dayMoment.format('D'),
                        ariaLabel: dayMoment.format('ll'),
                        value: dayMoment.valueOf(),
                        classes: {
                            'dl-abdtp-active': activeValue === dayMoment.valueOf(),
                            'dl-abdtp-future': dayMoment.isAfter(endOfMonth),
                            'dl-abdtp-past': dayMoment.isBefore(startOfMonth),
                            'dl-abdtp-selected': selectedValue === dayMoment.valueOf(),
                            'dl-abdtp-now': dayMoment.isSame(currentMoment, 'day'),
                        }
                    };
                });
                return { cells: cells };
            }
        };
        /**
         * Move the active `day` one row `down` from the specified moment in time.
         *
         * Moving `down` can result in the `active` day being part of a different month than
         * the specified `fromMilliseconds`, in this case the month represented by the model
         * will change to show the correct hour.
         *
         * @param fromMilliseconds
         *  the moment in time from which the next `day` model `down` will be constructed.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  model containing an `active` `day` one row `down` from the specified moment in time.
         */
        DlDayModelProvider.prototype.goDown = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$4(fromMilliseconds).add(7, 'days').valueOf(), selectedMilliseconds);
        };
        /**
         * Move the active `day` one row `up` from the specified moment in time.
         *
         * Moving `up` can result in the `active` day being part of a different month than
         * the specified `fromMilliseconds`, in this case the month represented by the model
         * will change to show the correct hour.
         *
         * @param fromMilliseconds
         *  the moment in time from which the next `day` model `up` will be constructed.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  model containing an `active` `day` one row `up` from the specified moment in time.
         */
        DlDayModelProvider.prototype.goUp = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$4(fromMilliseconds).subtract(7, 'days').valueOf(), selectedMilliseconds);
        };
        /**
         * Move the `active` day one cell `left` in the current `day` view.
         *
         * Moving `left` can result in the `active` day being part of a different month than
         * the specified `fromMilliseconds`, in this case the month represented by the model
         * will change to show the correct year.
         *
         * @param fromMilliseconds
         *  the moment in time from which the `day` model to the `left` will be constructed.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  model containing an `active` `day` one cell to the `left` of the specified moment in time.
         */
        DlDayModelProvider.prototype.goLeft = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$4(fromMilliseconds).subtract(1, 'day').valueOf(), selectedMilliseconds);
        };
        /**
         * Move the `active` day one cell `right` in the current `day` view.
         *
         * Moving `right` can result in the `active` day being part of a different month than
         * the specified `fromMilliseconds`, in this case the month represented by the model
         * will change to show the correct year.
         *
         * @param fromMilliseconds
         *  the moment in time from which the `day` model to the `right` will be constructed.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  model containing an `active` `day` one cell to the `right` of the specified moment in time.
         */
        DlDayModelProvider.prototype.goRight = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$4(fromMilliseconds).add(1, 'day').valueOf(), selectedMilliseconds);
        };
        /**
         * Move the active `day` one month `down` from the specified moment in time.
         *
         * Paging `down` will result in the `active` day being part of a different month than
         * the specified `fromMilliseconds`. As a result, the month represented by the model
         * will change to show the correct year.
         *
         * @param fromMilliseconds
         *  the moment in time from which the next `day` model page `down` will be constructed.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  model containing an `active` `day` one month `down` from the specified moment in time.
         */
        DlDayModelProvider.prototype.pageDown = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$4(fromMilliseconds).add(1, 'month').valueOf(), selectedMilliseconds);
        };
        /**
         * Move the active `day` one month `up` from the specified moment in time.
         *
         * Paging `up` will result in the `active` day being part of a different month than
         * the specified `fromMilliseconds`. As a result, the month represented by the model
         * will change to show the correct year.
         *
         * @param fromMilliseconds
         *  the moment in time from which the next `day` model page `up` will be constructed.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  model containing an `active` `day` one month `up` from the specified moment in time.
         */
        DlDayModelProvider.prototype.pageUp = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$4(fromMilliseconds).subtract(1, 'month').valueOf(), selectedMilliseconds);
        };
        /**
         * Move the `active` `day` to the last day of the month.
         *
         * The view or time range will not change unless the `fromMilliseconds` value
         * is in a different day than the displayed decade.
         *
         * @param fromMilliseconds
         *  the moment in time from which the last day of the month will be calculated.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  a model with the last cell in the view as the active `day`.
         */
        DlDayModelProvider.prototype.goEnd = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$4(fromMilliseconds)
                .endOf('month').startOf('day').valueOf(), selectedMilliseconds);
        };
        /**
         * Move the `active` `day` to the first day of the month.
         *
         * The view or time range will not change unless the `fromMilliseconds` value
         * is in a different day than the displayed decade.
         *
         * @param fromMilliseconds
         *  the moment in time from which the first day of the month will be calculated.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  a model with the first cell in the view as the active `day`.
         */
        DlDayModelProvider.prototype.goHome = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$4(fromMilliseconds).startOf('month').valueOf(), selectedMilliseconds);
        };
        return DlDayModelProvider;
    }());

    /**
     * @license
     * Copyright 2013-present Dale Lotts All Rights Reserved.
     * http://www.dalelotts.com
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://github.com/dalelotts/angular-bootstrap-datetimepicker/blob/master/LICENSE
     */
    /**
     * Work around for moment namespace conflict when used with webpack and rollup.
     * See https://github.com/dherges/ng-packagr/issues/163
     *
     * Depending on whether rollup is used, moment needs to be imported differently.
     * Since Moment.js doesn't have a default export, we normally need to import using
     * the `* as`syntax.
     *
     * rollup creates a synthetic default module and we thus need to import it using
     * the `default as` syntax.
     *
     * @internal
     **/
    var moment$5 = _moment;
    /**
     * Default implementation for the `hour` view.
     */
    var DlHourModelProvider = /** @class */ (function () {
        function DlHourModelProvider() {
        }
        /**
         * Receives input changes detected by Angular.
         *
         * @param changes
         *  the input changes detected by Angular.
         */
        DlHourModelProvider.prototype.onChanges = function (
        // @ts-ignore
        changes) { };
        /**
         * Returns the `hour` model for the specified moment in `local` time with the
         * `active` hour set to the beginning of the day.
         *
         * The `hour` model represents a day (24 hours) as six rows with four columns
         * and each cell representing one-hour increments.
         *
         * The hour always starts at the beginning of the hour.
         *
         * Each cell represents a one-hour increment starting at midnight.
         *
         * @param milliseconds
         *  the moment in time from which the minute model will be created.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  the model representing the specified moment in time.
         */
        DlHourModelProvider.prototype.getModel = function (milliseconds, selectedMilliseconds) {
            var startDate = moment$5(milliseconds).startOf('day');
            var rowNumbers = [0, 1, 2, 3, 4, 5];
            var columnNumbers = [0, 1, 2, 3];
            var previousDay = moment$5(startDate).subtract(1, 'day');
            var nextDay = moment$5(startDate).add(1, 'day');
            var activeValue = moment$5(milliseconds).startOf('hour').valueOf();
            var selectedValue = selectedMilliseconds === null || selectedMilliseconds === undefined
                ? selectedMilliseconds
                : moment$5(selectedMilliseconds).startOf('hour').valueOf();
            return {
                viewName: 'hour',
                viewLabel: startDate.format('ll'),
                activeDate: activeValue,
                leftButton: {
                    value: previousDay.valueOf(),
                    ariaLabel: "Go to " + previousDay.format('ll'),
                    classes: {},
                },
                upButton: {
                    value: startDate.valueOf(),
                    ariaLabel: "Go to " + startDate.format('MMM YYYY'),
                    classes: {},
                },
                rightButton: {
                    value: nextDay.valueOf(),
                    ariaLabel: "Go to " + nextDay.format('ll'),
                    classes: {},
                },
                rows: rowNumbers.map(rowOfHours)
            };
            function rowOfHours(rowNumber) {
                var currentMoment = moment$5();
                var cells = columnNumbers.map(function (columnNumber) {
                    var hourMoment = moment$5(startDate).add((rowNumber * columnNumbers.length) + columnNumber, 'hours');
                    return {
                        display: hourMoment.format('LT'),
                        ariaLabel: hourMoment.format('LLL'),
                        value: hourMoment.valueOf(),
                        classes: {
                            'dl-abdtp-active': activeValue === hourMoment.valueOf(),
                            'dl-abdtp-selected': selectedValue === hourMoment.valueOf(),
                            'dl-abdtp-now': hourMoment.isSame(currentMoment, 'hour'),
                        }
                    };
                });
                return { cells: cells };
            }
        };
        /**
         * Move the active `hour` one row `down` from the specified moment in time.
         *
         * Moving `down` can result in the `active` hour being part of a different day than
         * the specified `fromMilliseconds`, in this case the day represented by the model
         * will change to show the correct hour.
         *
         * @param fromMilliseconds
         *  the moment in time from which the next `hour` model `down` will be constructed.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  model containing an `active` `hour` one row `down` from the specified moment in time.
         */
        DlHourModelProvider.prototype.goDown = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$5(fromMilliseconds).add(4, 'hour').valueOf(), selectedMilliseconds);
        };
        /**
         * Move the active `hour` one row `up` from the specified moment in time.
         *
         * Moving `up` can result in the `active` hour being part of a different day than
         * the specified `fromMilliseconds`, in this case the day represented by the model
         * will change to show the correct hour.
         *
         * @param fromMilliseconds
         *  the moment in time from which the next `hour` model `up` will be constructed.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  model containing an `active` `hour` one row `up` from the specified moment in time.
         */
        DlHourModelProvider.prototype.goUp = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$5(fromMilliseconds).subtract(4, 'hour').valueOf(), selectedMilliseconds);
        };
        /**
         * Move the `active` hour one cell `left` in the current `hour` view.
         *
         * Moving `left` can result in the `active` hour being part of a different day than
         * the specified `fromMilliseconds`, in this case the day represented by the model
         * will change to show the correct year.
         *
         * @param fromMilliseconds
         *  the moment in time from which the `hour` model to the `left` will be constructed.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  model containing an `active` `hour` one cell to the `left` of the specified moment in time.
         */
        DlHourModelProvider.prototype.goLeft = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$5(fromMilliseconds).subtract(1, 'hour').valueOf(), selectedMilliseconds);
        };
        /**
         * Move the `active` hour one cell `right` in the current `hour` view.
         *
         * Moving `right` can result in the `active` hour being part of a different day than
         * the specified `fromMilliseconds`, in this case the day represented by the model
         * will change to show the correct year.
         *
         * @param fromMilliseconds
         *  the moment in time from which the `hour` model to the `right` will be constructed.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  model containing an `active` `hour` one cell to the `right` of the specified moment in time.
         */
        DlHourModelProvider.prototype.goRight = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$5(fromMilliseconds).add(1, 'hour').valueOf(), selectedMilliseconds);
        };
        /**
         * Move the active `hour` one day `down` from the specified moment in time.
         *
         * Paging `down` will result in the `active` hour being part of a different day than
         * the specified `fromMilliseconds`. As a result, the day represented by the model
         * will change to show the correct year.
         *
         * @param fromMilliseconds
         *  the moment in time from which the next `hour` model page `down` will be constructed.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  model containing an `active` `hour` one day `down` from the specified moment in time.
         */
        DlHourModelProvider.prototype.pageDown = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$5(fromMilliseconds).add(1, 'day').valueOf(), selectedMilliseconds);
        };
        /**
         * Move the active `hour` one day `up` from the specified moment in time.
         *
         * Paging `up` will result in the `active` hour being part of a different day than
         * the specified `fromMilliseconds`. As a result, the day represented by the model
         * will change to show the correct year.
         *
         * @param fromMilliseconds
         *  the moment in time from which the next `hour` model page `up` will be constructed.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  model containing an `active` `hour` one day `up` from the specified moment in time.
         */
        DlHourModelProvider.prototype.pageUp = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$5(fromMilliseconds).subtract(1, 'day').valueOf(), selectedMilliseconds);
        };
        /**
         * Move the `active` `hour` to `11:00 pm` of the current day.
         *
         * The view or time range will not change unless the `fromMilliseconds` value
         * is in a different day than the displayed decade.
         *
         * @param fromMilliseconds
         *  the moment in time from which `11:00 pm` will be calculated.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  a model with the `11:00 pm` cell in the view as the active `hour`.
         */
        DlHourModelProvider.prototype.goEnd = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$5(fromMilliseconds)
                .endOf('day')
                .startOf('hour')
                .valueOf(), selectedMilliseconds);
        };
        /**
         * Move the `active` `hour` to `midnight` of the current day.
         *
         * The view or time range will not change unless the `fromMilliseconds` value
         * is in a different day than the displayed decade.
         *
         * @param fromMilliseconds
         *  the moment in time from which `midnight` will be calculated.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  a model with the `midnight` cell in the view as the active `hour`.
         */
        DlHourModelProvider.prototype.goHome = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$5(fromMilliseconds).startOf('day').valueOf(), selectedMilliseconds);
        };
        return DlHourModelProvider;
    }());

    /**
     * @license
     * Copyright 2013-present Dale Lotts All Rights Reserved.
     * http://www.dalelotts.com
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://github.com/dalelotts/angular-bootstrap-datetimepicker/blob/master/LICENSE
     */
    /**
     * Work around for moment namespace conflict when used with webpack and rollup.
     * See https://github.com/dherges/ng-packagr/issues/163
     *
     * Depending on whether rollup is used, moment needs to be imported differently.
     * Since Moment.js doesn't have a default export, we normally need to import using
     * the `* as`syntax.
     *
     * rollup creates a synthetic default module and we thus need to import it using
     * the `default as` syntax.
     *
     * @internal
     **/
    var moment$6 = _moment;
    /**
     * Default implementation for the `minute` view.
     */
    var DlMinuteModelProvider = /** @class */ (function () {
        function DlMinuteModelProvider() {
            this.step = 5;
        }
        /**
         * Receives `minuteStep` configuration changes detected by Angular.
         *
         * Changes where the value has not changed are ignored.
         *
         * Setting `minuteStep` to `null` or `undefined` will result in a
         * minuteStep of `5`.
         *
         * @param changes
         *  the input changes detected by Angular.
         */
        DlMinuteModelProvider.prototype.onChanges = function (changes) {
            var minuteStepChange = changes['minuteStep'];
            if (minuteStepChange
                && (minuteStepChange.previousValue !== minuteStepChange.currentValue)) {
                this.step = minuteStepChange.currentValue;
                if (this.step === null || this.step === undefined) {
                    this.step = 5;
                }
            }
        };
        /**
         * Returns the `minute` model for the specified moment in `local` time with the
         * `active` minute set to the beginning of the hour.
         *
         * The `minute` model represents an hour (60 minutes) as three rows with four columns
         * and each cell representing 5-minute increments.
         *
         * The hour always starts at midnight.
         *
         * Each cell represents a 5-minute increment starting at midnight.
         *
         * The `active` minute will be the 5-minute increments less than or equal to the specified milliseconds.
         *
         * @param milliseconds
         *  the moment in time from which the minute model will be created.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  the model representing the specified moment in time.
         */
        DlMinuteModelProvider.prototype.getModel = function (milliseconds, selectedMilliseconds) {
            var _this = this;
            var startDate = moment$6(milliseconds).startOf('hour');
            var currentMilliseconds = moment$6().valueOf();
            var minuteSteps = new Array(Math.ceil(60 / this.step)).fill(0).map(function (zero, index) { return zero + index * _this.step; });
            var minuteValues = minuteSteps.map(function (minutesToAdd) { return moment$6(startDate).add(minutesToAdd, 'minutes').valueOf(); });
            var activeValue = moment$6(minuteValues.filter(function (value) { return value <= milliseconds; }).pop()).valueOf();
            var nowValue = currentMilliseconds >= startDate.valueOf() && currentMilliseconds <= moment$6(startDate).endOf('hour').valueOf()
                ? moment$6(minuteValues.filter(function (value) { return value <= currentMilliseconds; }).pop()).valueOf()
                : null;
            var previousHour = moment$6(startDate).subtract(1, 'hour');
            var nextHour = moment$6(startDate).add(1, 'hour');
            var selectedValue = selectedMilliseconds === null || selectedMilliseconds === undefined
                ? selectedMilliseconds
                : moment$6(minuteValues.filter(function (value) { return value <= selectedMilliseconds; }).pop()).valueOf();
            var rows = new Array(Math.ceil(minuteSteps.length / 4))
                .fill(0)
                .map(function (zero, index) { return zero + index; })
                .map(function (value) {
                return { cells: minuteSteps.slice((value * 4), (value * 4) + 4).map(rowOfMinutes) };
            });
            return {
                viewName: 'minute',
                viewLabel: startDate.format('lll'),
                activeDate: activeValue,
                leftButton: {
                    value: previousHour.valueOf(),
                    ariaLabel: "Go to " + previousHour.format('lll'),
                    classes: {},
                },
                upButton: {
                    value: startDate.valueOf(),
                    ariaLabel: "Go to " + startDate.format('ll'),
                    classes: {},
                },
                rightButton: {
                    value: nextHour.valueOf(),
                    ariaLabel: "Go to " + nextHour.format('lll'),
                    classes: {},
                },
                rows: rows
            };
            function rowOfMinutes(stepMinutes) {
                var minuteMoment = moment$6(startDate).add(stepMinutes, 'minutes');
                return {
                    display: minuteMoment.format('LT'),
                    ariaLabel: minuteMoment.format('LLL'),
                    value: minuteMoment.valueOf(),
                    classes: {
                        'dl-abdtp-active': activeValue === minuteMoment.valueOf(),
                        'dl-abdtp-selected': selectedValue === minuteMoment.valueOf(),
                        'dl-abdtp-now': nowValue === minuteMoment.valueOf(),
                    }
                };
            }
        };
        /**
         * Move the active `minute` one row `down` from the specified moment in time.
         *
         * Moving `down` can result in the `active` minute being part of a different hour than
         * the specified `fromMilliseconds`, in this case the hour represented by the model
         * will change to show the correct hour.
         *
         * @param fromMilliseconds
         *  the moment in time from which the next `minute` model `down` will be constructed.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  model containing an `active` `minute` one row `down` from the specified moment in time.
         */
        DlMinuteModelProvider.prototype.goDown = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$6(fromMilliseconds).add(this.step * 4, 'minutes').valueOf(), selectedMilliseconds);
        };
        /**
         * Move the active `minute` one row `down` from the specified moment in time.
         *
         * Moving `down` can result in the `active` minute being part of a different hour than
         * the specified `fromMilliseconds`, in this case the hour represented by the model
         * will change to show the correct hour.
         *
         * @param fromMilliseconds
         *  the moment in time from which the next `minute` model `down` will be constructed.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  model containing an `active` `minute` one row `down` from the specified moment in time.
         */
        DlMinuteModelProvider.prototype.goUp = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$6(fromMilliseconds).subtract(this.step * 4, 'minutes').valueOf(), selectedMilliseconds);
        };
        /**
         * Move the `active` date one cell to `left` in the current `minute` view.
         *
         * Moving `left` can result in the `active` hour being part of a different hour than
         * the specified `fromMilliseconds`, in this case the hour represented by the model
         * will change to show the correct hour.
         *
         * @param fromMilliseconds
         *  the moment in time from which the `minute` model to the `left` will be constructed.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  model containing an `active` `minute` one cell to the `left` of the specified moment in time.
         */
        DlMinuteModelProvider.prototype.goLeft = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$6(fromMilliseconds).subtract(this.step, 'minutes').valueOf(), selectedMilliseconds);
        };
        /**
         * Move `active` minute one cell to `right` in the current `minute` view.
         *
         * Moving `right` can result in the `active` hour being part of a different hour than
         * the specified `fromMilliseconds`, in this case the hour represented by the model
         * will change to show the correct hour.
         *
         * @param fromMilliseconds
         *  the moment in time from which the `minute` model to the `right` will be constructed.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  model containing an `active` `minute` one cell to the `right` of the specified moment in time.
         */
        DlMinuteModelProvider.prototype.goRight = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$6(fromMilliseconds).add(this.step, 'minutes').valueOf(), selectedMilliseconds);
        };
        /**
         * Move the active `minute` one hour `down` from the specified moment in time.
         *
         * The `active` minute will be `one (1) hour after` the specified milliseconds.
         * This moves the `active` date one `page` `down` from the current `minute` view.
         *
         * The next cell `page-down` will be in a different hour than the currently
         * displayed view and the model time range will include the new active cell.
         *
         * @param fromMilliseconds
         *  the moment in time from which the next `month` model page `down` will be constructed.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  model containing an `active` `month` one year `down` from the specified moment in time.
         */
        DlMinuteModelProvider.prototype.pageDown = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$6(fromMilliseconds).add(1, 'hour').valueOf(), selectedMilliseconds);
        };
        /**
         * Move the active `minute` one hour `up` from the specified moment in time.
         *
         * The `active` minute will be `one (1) hour before` the specified milliseconds.
         * This moves the `active` date one `page` `down` from the current `minute` view.
         *
         * The next cell `page-up` will be in a different hour than the currently
         * displayed view and the model time range will include the new active cell.
         *
         * @param fromMilliseconds
         *  the moment in time from which the next `month` model page `down` will be constructed.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  model containing an `active` `month` one year `down` from the specified moment in time.
         */
        DlMinuteModelProvider.prototype.pageUp = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$6(fromMilliseconds).subtract(1, 'hour').valueOf(), selectedMilliseconds);
        };
        /**
         * Move the `active` `minute` to the last cell of the current hour.
         *
         * The view or time range will not change unless the `fromMilliseconds` value
         * is in a different hour than the displayed decade.
         *
         * @param fromMilliseconds
         *  the moment in time from which the last cell will be calculated.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  a model with the last cell in the view as the active `minute`.
         */
        DlMinuteModelProvider.prototype.goEnd = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$6(fromMilliseconds)
                .endOf('hour')
                .valueOf(), selectedMilliseconds);
        };
        /**
         * Move the `active` `minute` to the first cell of the current hour.
         *
         * The view or time range will not change unless the `fromMilliseconds` value
         * is in a different hour than the displayed decade.
         *
         * @param fromMilliseconds
         *  the moment in time from which the first cell will be calculated.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  a model with the first cell in the view as the active `minute`.
         */
        DlMinuteModelProvider.prototype.goHome = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$6(fromMilliseconds).startOf('hour').valueOf(), selectedMilliseconds);
        };
        return DlMinuteModelProvider;
    }());

    /**
     * @license
     * Copyright 2013-present Dale Lotts All Rights Reserved.
     * http://www.dalelotts.com
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://github.com/dalelotts/angular-bootstrap-datetimepicker/blob/master/LICENSE
     */
    /**
     * Work around for moment namespace conflict when used with webpack and rollup.
     * See https://github.com/dherges/ng-packagr/issues/163
     *
     * Depending on whether rollup is used, moment needs to be imported differently.
     * Since Moment.js doesn't have a default export, we normally need to import using
     * the `* as`syntax.
     *
     * rollup creates a synthetic default module and we thus need to import it using
     * the `default as` syntax.
     *
     * @internal
     **/
    var moment$7 = _moment;
    /**
     * Default implementation for the `month` view.
     */
    var DlMonthModelProvider = /** @class */ (function () {
        function DlMonthModelProvider() {
        }
        /**
         * Receives input changes detected by Angular.
         *
         * @param changes
         *  the input changes detected by Angular.
         */
        DlMonthModelProvider.prototype.onChanges = function (
        // @ts-ignore
        changes) { };
        /**
         * Returns the `month` model for the specified moment in `local` time with the
         * `active` month set to the first day of the specified month.
         *
         * The `month` model represents a year (12 months) as three rows with four columns.
         *
         * The year always starts in January.
         *
         * Each cell represents midnight on the 1st day of the month.
         *
         * The `active` month will be the January of year of the specified milliseconds.
         *
         * @param milliseconds
         *  the moment in time from which the month model will be created.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  the model representing the specified moment in time.
         */
        DlMonthModelProvider.prototype.getModel = function (milliseconds, selectedMilliseconds) {
            var startDate = moment$7(milliseconds).startOf('year');
            var rowNumbers = [0, 1, 2];
            var columnNumbers = [0, 1, 2, 3];
            var previousYear = moment$7(startDate).subtract(1, 'year');
            var nextYear = moment$7(startDate).add(1, 'year');
            var activeValue = moment$7(milliseconds).startOf('month').valueOf();
            var selectedValue = selectedMilliseconds === null || selectedMilliseconds === undefined
                ? selectedMilliseconds
                : moment$7(selectedMilliseconds).startOf('month').valueOf();
            return {
                viewName: 'month',
                viewLabel: startDate.format('YYYY'),
                activeDate: activeValue,
                leftButton: {
                    value: previousYear.valueOf(),
                    ariaLabel: "Go to " + previousYear.format('YYYY'),
                    classes: {},
                },
                upButton: {
                    value: startDate.valueOf(),
                    ariaLabel: "Go to " + startDate.format('YYYY'),
                    classes: {},
                },
                rightButton: {
                    value: nextYear.valueOf(),
                    ariaLabel: "Go to " + nextYear.format('YYYY'),
                    classes: {},
                },
                rows: rowNumbers.map(rowOfMonths)
            };
            function rowOfMonths(rowNumber) {
                var currentMoment = moment$7();
                var cells = columnNumbers.map(function (columnNumber) {
                    var monthMoment = moment$7(startDate).add((rowNumber * columnNumbers.length) + columnNumber, 'months');
                    return {
                        display: monthMoment.format('MMM'),
                        ariaLabel: monthMoment.format('MMM YYYY'),
                        value: monthMoment.valueOf(),
                        classes: {
                            'dl-abdtp-active': activeValue === monthMoment.valueOf(),
                            'dl-abdtp-selected': selectedValue === monthMoment.valueOf(),
                            'dl-abdtp-now': monthMoment.isSame(currentMoment, 'month'),
                        }
                    };
                });
                return { cells: cells };
            }
        };
        /**
         * Move the active `month` one row `down` from the specified moment in time.
         *
         * Moving `down` can result in the `active` month being part of a different year than
         * the specified `fromMilliseconds`, in this case the year represented by the model
         * will change to show the correct year.
         *
         * @param fromMilliseconds
         *  the moment in time from which the next `month` model `down` will be constructed.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  model containing an `active` `month` one row `down` from the specified moment in time.
         */
        DlMonthModelProvider.prototype.goDown = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$7(fromMilliseconds).add(4, 'month').valueOf(), selectedMilliseconds);
        };
        /**
         * Move the active `month` one row `up` from the specified moment in time.
         *
         * Moving `up` can result in the `active` month being part of a different year than
         * the specified `fromMilliseconds`, in this case the year represented by the model
         * will change to show the correct year.
         *
         * @param fromMilliseconds
         *  the moment in time from which the previous `month` model `up` will be constructed.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  model containing an `active` `month` one row `up` from the specified moment in time.
         */
        DlMonthModelProvider.prototype.goUp = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$7(fromMilliseconds).subtract(4, 'month').valueOf(), selectedMilliseconds);
        };
        /**
         * Move the `active` `month` one (1) month to the `left` of the specified moment in time.
         *
         * Moving `left` can result in the `active` month being part of a different year than
         * the specified `fromMilliseconds`, in this case the year represented by the model
         * will change to show the correct year.
         *
         * @param fromMilliseconds
         *  the moment in time from which the `month` model to the `left` will be constructed.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  model containing an `active` `month` one month to the `left` of the specified moment in time.
         */
        DlMonthModelProvider.prototype.goLeft = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$7(fromMilliseconds).subtract(1, 'month').valueOf(), selectedMilliseconds);
        };
        /**
         * Move the `active` `month` one (1) month to the `right` of the specified moment in time.
         *
         * The `active` month will be `one (1) month after` the specified milliseconds.
         * This moves the `active` date one month `right` in the current `month` view.
         *
         * Moving `right` can result in the `active` month being part of a different year than
         * the specified `fromMilliseconds`, in this case the year represented by the model
         * will change to show the correct year.
         *
         * @param fromMilliseconds
         *  the moment in time from which the `month` model to the `right` will be constructed.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  model containing an `active` `month` one year to the `right` of the specified moment in time.
         */
        DlMonthModelProvider.prototype.goRight = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$7(fromMilliseconds).add(1, 'month').valueOf(), selectedMilliseconds);
        };
        /**
         * Move the active `month` one year `down` from the specified moment in time.
         *
         * Paging `down` will result in the `active` month being part of a different year than
         * the specified `fromMilliseconds`. As a result, the year represented by the model
         * will change to show the correct year.
         *
         * @param fromMilliseconds
         *  the moment in time from which the next `month` model page `down` will be constructed.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  model containing an `active` `month` one year `down` from the specified moment in time.
         */
        DlMonthModelProvider.prototype.pageDown = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$7(fromMilliseconds).add(12, 'months').valueOf(), selectedMilliseconds);
        };
        /**
         * Move the active `month` one year `down` from the specified moment in time.
         *
         * Paging `up` will result in the `active` month being part of a different year than
         * the specified `fromMilliseconds`. As a result, the year represented by the model
         * will change to show the correct year.
         *
         * @param fromMilliseconds
         *  the moment in time from which the next `month` model page `up` will be constructed.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  model containing an `active` `month` one year `up` from the specified moment in time.
         */
        DlMonthModelProvider.prototype.pageUp = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$7(fromMilliseconds).subtract(12, 'months').valueOf(), selectedMilliseconds);
        };
        /**
         * Move the `active` `month` to `December` of the current year.
         *
         * The view or time range will not change unless the `fromMilliseconds` value
         * is in a different year than the displayed decade.
         *
         * @param fromMilliseconds
         *  the moment in time from which `December 1` will be calculated.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  a model with the `December` cell in the view as the active `month`.
         */
        DlMonthModelProvider.prototype.goEnd = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$7(fromMilliseconds).endOf('year').valueOf(), selectedMilliseconds);
        };
        /**
         * Move the `active` `month` to `January` of the current year.
         *
         * The view or time range will not change unless the `fromMilliseconds` value
         * is in a different year than the displayed decade.
         *
         * @param fromMilliseconds
         *  the moment in time from which `January 1` will be calculated.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  a model with the `January` cell in the view as the active `month`.
         */
        DlMonthModelProvider.prototype.goHome = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$7(fromMilliseconds).startOf('year').valueOf(), selectedMilliseconds);
        };
        return DlMonthModelProvider;
    }());

    /**
     * @license
     * Copyright 2013-present Dale Lotts All Rights Reserved.
     * http://www.dalelotts.com
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://github.com/dalelotts/angular-bootstrap-datetimepicker/blob/master/LICENSE
     */
    /**
     * Work around for moment namespace conflict when used with webpack and rollup.
     * See https://github.com/dherges/ng-packagr/issues/163
     *
     * Depending on whether rollup is used, moment needs to be imported differently.
     * Since Moment.js doesn't have a default export, we normally need to import using
     * the `* as`syntax.
     *
     * rollup creates a synthetic default module and we thus need to import it using
     * the `default as` syntax.
     *
     * @internal
     **/
    var moment$8 = _moment;
    /**
     * Default implementation for the `year` view.
     */
    var DlYearModelProvider = /** @class */ (function () {
        function DlYearModelProvider() {
        }
        /**
         * Create a moment at midnight january 1 at the start of the current decade.
         * The start of the decade is always a year ending in zero.
         *
         * @param fromMilliseconds
         *  the moment in time from which the start of the decade will be determined.
         * @returns
         *  moment at midnight january 1 at the start of the current decade.
         * @internal
         */
        DlYearModelProvider.getStartOfDecade = function (fromMilliseconds) {
            // Truncate the last digit from the current year to get the start of the decade
            var startDecade = (Math.trunc(moment$8(fromMilliseconds).year() / 10) * 10);
            return moment$8({ year: startDecade }).startOf('year');
        };
        /**
         * Receives input changes detected by Angular.
         *
         * @param changes
         *  the input changes detected by Angular.
         */
        DlYearModelProvider.prototype.onChanges = function (
        // @ts-ignore
        changes) { };
        /**
         * Returns the `year` model for the specified moment in `local` time with the
         * `active` year set to January 1 of the specified year.
         *
         * The `year` model represents a decade (10 years) as two rows with five columns.
         *
         * The decade always starts on a year ending with zero.
         *
         * Each cell represents midnight January 1 of the indicated year.
         *
         * The `active` year will be the January 1 of year of the specified milliseconds.
         *
         * @param milliseconds
         *  the moment in time from which the year model will be created.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  the model representing the specified moment in time.
         */
        DlYearModelProvider.prototype.getModel = function (milliseconds, selectedMilliseconds) {
            var rowNumbers = [0, 1];
            var columnNumbers = [0, 1, 2, 3, 4];
            var startYear = moment$8(milliseconds).startOf('year');
            var startDate = DlYearModelProvider.getStartOfDecade(milliseconds);
            var futureYear = startDate.year() + 9;
            var pastYear = startDate.year();
            var activeValue = startYear.valueOf();
            var selectedValue = selectedMilliseconds === null || selectedMilliseconds === undefined
                ? selectedMilliseconds
                : moment$8(selectedMilliseconds).startOf('year').valueOf();
            return {
                viewName: 'year',
                viewLabel: pastYear + "-" + futureYear,
                activeDate: activeValue,
                leftButton: {
                    value: moment$8(startDate).subtract(10, 'years').valueOf(),
                    ariaLabel: "Go to " + (pastYear - 10) + "-" + (pastYear - 1),
                    classes: {},
                },
                rightButton: {
                    value: moment$8(startDate).add(10, 'years').valueOf(),
                    ariaLabel: "Go to " + (futureYear + 1) + "-" + (futureYear + 10),
                    classes: {},
                },
                rows: rowNumbers.map(rowOfYears.bind(this))
            };
            function rowOfYears(rowNumber) {
                var currentMoment = moment$8();
                var cells = columnNumbers.map(function (columnNumber) {
                    var yearMoment = moment$8(startDate).add((rowNumber * columnNumbers.length) + columnNumber, 'years');
                    return {
                        display: yearMoment.format('YYYY'),
                        value: yearMoment.valueOf(),
                        classes: {
                            'dl-abdtp-active': activeValue === yearMoment.valueOf(),
                            'dl-abdtp-selected': selectedValue === yearMoment.valueOf(),
                            'dl-abdtp-now': yearMoment.isSame(currentMoment, 'year'),
                        }
                    };
                });
                return { cells: cells };
            }
        };
        /**
         * Move the active `year` one row `down` from the specified moment in time.
         *
         * The `active` year will be the January 1 `five (5) years after` the specified milliseconds.
         * This moves the `active` date one row `down` in the current `year` view.
         *
         * Moving `down` can result in the `active` year being part of a different decade than
         * the specified `fromMilliseconds`, in this case the decade represented by the model
         * will change to show the correct decade.
         *
         * @param fromMilliseconds
         *  the moment in time from which the next `year` model `down` will be constructed.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  model containing an `active` `year` one row `down` from the specified moment in time.
         */
        DlYearModelProvider.prototype.goDown = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$8(fromMilliseconds).add(5, 'year').valueOf(), selectedMilliseconds);
        };
        /**
         * Move the active `year` one row `up` from the specified moment in time.
         *
         * The `active` year will be the January 1 `five (5) years before` the specified milliseconds.
         * This moves the `active` date one row `up` in the current `year` view.
         *
         * Moving `up` can result in the `active` year being part of a different decade than
         * the specified `fromMilliseconds`, in this case the decade represented by the model
         * will change to show the correct decade.
         *
         * @param fromMilliseconds
         *  the moment in time from which the previous `year` model `up` will be constructed.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  model containing an `active` `year` one row `up` from the specified moment in time.
         */
        DlYearModelProvider.prototype.goUp = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$8(fromMilliseconds).subtract(5, 'year').valueOf(), selectedMilliseconds);
        };
        /**
         * Move the `active` `year` one (1) year to the `left` of the specified moment in time.
         *
         * The `active` year will be the January 1 `one (1) year before` the specified milliseconds.
         * This moves the `active` date one year `left` in the current `year` view.
         *
         * Moving `left` can result in the `active` year being part of a different decade than
         * the specified `fromMilliseconds`, in this case the decade represented by the model
         * will change to show the correct decade.
         *
         * @param fromMilliseconds
         *  the moment in time from which the `year` model to the `left` will be constructed.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  model containing an `active` `year` one year to the `left` of the specified moment in time.
         */
        DlYearModelProvider.prototype.goLeft = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$8(fromMilliseconds).subtract(1, 'year').valueOf(), selectedMilliseconds);
        };
        /**
         * Move the `active` `year` one (1) year to the `right` of the specified moment in time.
         *
         * The `active` year will be the January 1 `one (1) year after` the specified milliseconds.
         * This moves the `active` date one year `right` in the current `year` view.
         *
         * Moving `right` can result in the `active` year being part of a different decade than
         * the specified `fromMilliseconds`, in this case the decade represented by the model
         * will change to show the correct decade.
         *
         * @param fromMilliseconds
         *  the moment in time from which the `year` model to the `right` will be constructed.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  model containing an `active` `year` one year to the `right` of the specified moment in time.
         */
        DlYearModelProvider.prototype.goRight = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$8(fromMilliseconds).add(1, 'year').valueOf(), selectedMilliseconds);
        };
        /**
         * Move the active `year` one decade `down` from the specified moment in time.
         *
         * The `active` year will be the January 1 `ten (10) years after` the specified milliseconds.
         * This moves the `active` date one `page` `down` from the current `year` view.
         *
         * Paging `down` will result in the `active` year being part of a different decade than
         * the specified `fromMilliseconds`. As a result, the decade represented by the model
         * will change to show the correct decade.
         *
         * @param fromMilliseconds
         *  the moment in time from which the next `year` model page `down` will be constructed.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  model containing an `active` `year` one decade `down` from the specified moment in time.
         */
        DlYearModelProvider.prototype.pageDown = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$8(fromMilliseconds).add(10, 'year').valueOf(), selectedMilliseconds);
        };
        /**
         * Move the active `year` one decade `up` from the specified moment in time.
         *
         * The `active` year will be the January 1 `ten (10) years before` the specified milliseconds.
         * This moves the `active` date one `page-up` from the current `year` view.
         *
         * Paging `up` will result in the `active` year being part of a different decade than
         * the specified `fromMilliseconds`. As a result, the decade represented by the model
         * will change to show the correct decade.
         *
         * @param fromMilliseconds
         *  the moment in time from which the next `year` model page `up` will be constructed.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  model containing an `active` `year` one decade `up` from the specified moment in time.
         */
        DlYearModelProvider.prototype.pageUp = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(moment$8(fromMilliseconds).subtract(10, 'year').valueOf(), selectedMilliseconds);
        };
        /**
         * Move the `active` `year` to the `last` year in the decade.
         *
         * The view or time range will not change unless the `fromMilliseconds` value
         * is in a different decade than the displayed decade.
         *
         * @param fromMilliseconds
         *  the moment in time from which the `last` active `year` will be calculated.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  a model with the `last` cell in the view as the active `year`.
         */
        DlYearModelProvider.prototype.goEnd = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(DlYearModelProvider.getStartOfDecade(fromMilliseconds)
                .add(9, 'years')
                .endOf('year')
                .valueOf(), selectedMilliseconds);
        };
        /**
         * Move the `active` `year` to the `first` year in the decade.
         *
         * The view or time range will not change unless the `fromMilliseconds` value
         * is in a different decade than the displayed decade.
         *
         * @param fromMilliseconds
         *  the moment in time from which the `first` active `year` will be calculated.
         * @param selectedMilliseconds
         *  the current value of the date/time picker.
         * @returns
         *  a model with the `first` cell in the view as the active `year`.
         */
        DlYearModelProvider.prototype.goHome = function (fromMilliseconds, selectedMilliseconds) {
            return this.getModel(DlYearModelProvider.getStartOfDecade(fromMilliseconds)
                .startOf('year')
                .valueOf(), selectedMilliseconds);
        };
        return DlYearModelProvider;
    }());

    /**
     * @license
     * Copyright 2013-present Dale Lotts All Rights Reserved.
     * http://www.dalelotts.com
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://github.com/dalelotts/angular-bootstrap-datetimepicker/blob/master/LICENSE
     */
    /**
     * Work around for moment namespace conflict when used with webpack and rollup.
     * See https://github.com/dherges/ng-packagr/issues/163
     *
     * Depending on whether rollup is used, moment needs to be imported differently.
     * Since Moment.js doesn't have a default export, we normally need to import using
     * the `* as`syntax.
     *
     * rollup creates a synthetic default module and we thus need to import it using
     * the `default as` syntax.
     *
     * @internal
     **/
    var moment$9 = _moment;
    /**
     * Maps key codes to the model provider function name
     * that should be called to perform the action.
     *
     * @internal
     **/
    var keyCodeToModelProviderMethod = {
        'ArrowDown': 'goDown',
        'ArrowLeft': 'goLeft',
        'ArrowRight': 'goRight',
        'ArrowUp': 'goUp',
        'Down': 'goDown',
        'End': 'goEnd',
        'Home': 'goHome',
        'Left': 'goLeft',
        'PageDown': 'pageDown',
        'PageUp': 'pageUp',
        'Right': 'goRight',
        'Up': 'goUp',
        33: 'pageUp',
        34: 'pageDown',
        35: 'goEnd',
        36: 'goHome',
        37: 'goLeft',
        38: 'goUp',
        39: 'goRight',
        40: 'goDown',
    };
    /**
     * List of view names for the calendar.
     *
     * This list must be in order from
     * smallest increment of time to largest increment of time.
     *
     * @internal
     **/
    var VIEWS = [
        'minute',
        'hour',
        'day',
        'month',
        'year'
    ];
    /**
     * Component that provides all of the user facing functionality of the date/time picker.
     */
    var DlDateTimePickerComponent = /** @class */ (function () {
        /**
         * Used to construct a new instance of a date/time picker.
         *
         * @param _elementRef
         *  reference to this element.
         * @param _ngZone
         *  reference to an NgZone instance used to select the active element outside of angular.
         * @param _dateAdapter
         *  date adapter for the date type in the model.
         * @param yearModelComponent
         *  provider for the year view model.
         * @param monthModelComponent
         *  provider for the month view model.
         * @param dayModelComponent
         *  provider for the day view model.
         * @param hourModelComponent
         *  provider for the hour view model.
         * @param minuteModelComponent
         *  provider for the minute view model.
         */
        function DlDateTimePickerComponent(_elementRef, _ngZone, _dateAdapter, 
        // @ts-ignore
        yearModelComponent, 
        // @ts-ignore
        monthModelComponent, 
        // @ts-ignore
        dayModelComponent, 
        // @ts-ignore
        hourModelComponent, 
        // @ts-ignore
        minuteModelComponent) {
            this._elementRef = _elementRef;
            this._ngZone = _ngZone;
            this._dateAdapter = _dateAdapter;
            this.yearModelComponent = yearModelComponent;
            this.monthModelComponent = monthModelComponent;
            this.dayModelComponent = dayModelComponent;
            this.hourModelComponent = hourModelComponent;
            this.minuteModelComponent = minuteModelComponent;
            /**
             * Change listener callback functions registered
             * via `registerOnChange`
             * @internal
             **/
            this._changed = [];
            /**
             * Maps view name to the next view (the view for the next smallest increment of time).
             * @internal
             **/
            this._nextView = {
                'year': 'month',
                'month': 'day',
                'day': 'hour',
                'hour': 'minute'
            };
            /**
             * Maps view name to the previous view (the view for the next largest increment of time).
             * @internal
             **/
            this._previousView = {
                'minute': 'hour',
                'hour': 'day',
                'day': 'month',
                'month': 'year'
            };
            /**
             * Touch listener callback functions registered
             * via `registerOnChange`
             * @internal
             **/
            this._touched = [];
            /**
             * Emits when a `change` event when date/time is selected or
             * the value of the date/time picker changes.
             **/
            this.change = new core.EventEmitter();
            /**
             * Specifies the classes used to display the left icon.
             *
             * This component uses OPENICONIC https://useiconic.com/open
             * by default but any icon library may be used.
             */
            this.leftIconClass = [
                'oi',
                'oi-chevron-left'
            ];
            /**
             * The highest view that the date/time picker can show.
             * Setting this to a view less than year could make it more
             * difficult for the end-user to navigate to certain dates.
             */
            this.maxView = 'year';
            /**
             * The view that will be used for date/time selection.
             *
             * The default of `minute  means that selection will not happen
             * until the end-user clicks on a cell in the minute view.
             *
             * for example, if you want the end-user to select a only day (date),
             * setting `minView` to `day` will cause selection to happen when the
             * end-user selects a cell in the day view.
             *
             * NOTE: This must be set lower than or equal to `startView'
             */
            this.minView = 'minute';
            /**
             * The number of minutes between each `.dl-abdtp-minute` button.
             *
             * Must be greater than `0` and less than `60`.
             */
            this.minuteStep = 5;
            /**
             * Specifies the classes used to display the right icon.
             *
             * This component uses OPENICONIC https://useiconic.com/open
             * by default but any icon library may be used.
             */
            this.rightIconClass = [
                'oi',
                'oi-chevron-right'
            ];
            /* tslint:disable:member-ordering */
            /**
             *  Determine whether or not the `DateButton` is selectable by the end user.
             */
            this.selectFilter = function () { return true; };
            /**
             * The initial view that the date/time picker will show.
             * The picker will also return to this view after a date/time
             * is selected.
             *
             * NOTE: This must be set lower than or equal to `maxView'
             */
            this.startView = 'day';
            /**
             * Specifies the classes used to display the up icon.
             *
             * This component uses OPENICONIC https://useiconic.com/open
             * by default but any icon library may be used.
             */
            this.upIconClass = [
                'oi',
                'oi-chevron-top'
            ];
            this._viewToModelProvider = {
                year: yearModelComponent,
                month: monthModelComponent,
                day: dayModelComponent,
                hour: hourModelComponent,
                minute: minuteModelComponent,
            };
        }
        DlDateTimePickerComponent_1 = DlDateTimePickerComponent;
        Object.defineProperty(DlDateTimePickerComponent.prototype, "model", {
            /* tslint:enable:member-ordering */
            /**
             * Set's the model for the current view after applying the selection filter.
             *
             * @internal
             **/
            set: function (model) {
                this._model = this.applySelectFilter(model);
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DlDateTimePickerComponent.prototype, "value", {
            /**
             * Returns `D` value of the date/time picker or undefined/null if no value is set.
             **/
            get: function () {
                return this._value;
            },
            /**
             * Sets value of the date/time picker and emits a change event if the
             * new value is different from the previous value.
             **/
            set: function (value) {
                if (this._value !== value) {
                    this._value = value;
                    this.model = this._viewToModelProvider[this._model.viewName].getModel(this.getStartDate(), this.valueOf);
                    this._changed.forEach(function (f) { return f(value); });
                    this.change.emit(new DlDateTimePickerChange(value));
                }
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(DlDateTimePickerComponent.prototype, "valueOf", {
            /**
             * Returns `milliseconds` value of the date/time picker or undefined/null if no value is set.
             **/
            get: function () {
                return this._dateAdapter.toMilliseconds(this._value);
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Applies the `selectionFilter` by adding the `dl-abdtp-disabled`
         * class to any `DateButton` where `selectFilter` returned false.
         *
         * @param model
         *  the new model
         *
         * @returns
         *  the supplied model with zero or more `DateButton`'s
         *  having the `dl-abdtp-disabled` class set to `true` if the
         *  selection for that date should be disabled.
         *
         * @internal
         */
        DlDateTimePickerComponent.prototype.applySelectFilter = function (model) {
            var _this = this;
            if (this.selectFilter) {
                model.rows = model.rows.map(function (row) {
                    row.cells.map(function (dateButton) {
                        var disabled = !_this.selectFilter(dateButton, model.viewName);
                        dateButton.classes['dl-abdtp-disabled'] = disabled;
                        if (disabled) {
                            dateButton.classes['aria-disabled'] = true;
                        }
                        return dateButton;
                    });
                    return row;
                });
            }
            return model;
        };
        /**
         * Focuses the `.dl-abdtp-active` cell after the microtask queue is empty.
         * @internal
         **/
        DlDateTimePickerComponent.prototype.focusActiveCell = function () {
            var _this = this;
            this._ngZone.runOutsideAngular(function () {
                _this._ngZone.onStable.asObservable().pipe(operators.take(1)).subscribe(function () {
                    _this._elementRef.nativeElement.querySelector('.dl-abdtp-active').focus();
                });
            });
        };
        /**
         * Determines the start date for the picker.
         * @internal
         **/
        DlDateTimePickerComponent.prototype.getStartDate = function () {
            if (hasValue(this._value)) {
                return this._dateAdapter.toMilliseconds(this._value);
            }
            if (hasValue(this.startDate)) {
                return this.startDate;
            }
            return moment$9().valueOf();
        };
        /**
         * Determine the start view for the picker
         * @returns
         *  the largest time increment view between the `minView` or `minute` view and the `startView` or `day` view.
         */
        DlDateTimePickerComponent.prototype.getStartView = function () {
            var startIndex = Math.max(VIEWS.indexOf(this.minView || 'minute'), VIEWS.indexOf(this.startView || 'day'));
            return VIEWS[startIndex];
        };
        /**
         * Calls all registered `touch` callback functions.
         * @internal
         **/
        DlDateTimePickerComponent.prototype.onTouch = function () {
            this._touched.forEach(function (onTouched) { return onTouched(); });
        };
        /**
         * Receives configuration changes detected by Angular and passes the changes on
         * to the model providers so the provider is aware of any necessary configuration
         * changes (i.e. minuteStep)
         *
         * @param changes
         *  the input changes detected by Angular.
         */
        DlDateTimePickerComponent.prototype.ngOnChanges = function (changes) {
            Object.values(this._viewToModelProvider).forEach(function (provider) { return provider.onChanges(changes); });
            if (this._model) { // only update the model after ngOnInit has set it the first time.
                this.model = this._viewToModelProvider[this._model.viewName].getModel(this._model.activeDate, this.valueOf);
            }
        };
        /**
         * Sets the initial model.
         *
         * @internal
         **/
        DlDateTimePickerComponent.prototype.ngOnInit = function () {
            this.model = this._viewToModelProvider[this.getStartView()].getModel(this.getStartDate(), this.valueOf);
        };
        /**
         * Handles click (and enter & space key down) events on the date elements.
         *
         * If the current view is the minimum view then the date value is selected
         * and the picker returns to the start view.
         *
         * Otherwise the picker displays the next view with the next
         * smallest time increment.
         *
         * @internal
         **/
        DlDateTimePickerComponent.prototype._onDateClick = function (dateButton) {
            if (dateButton.classes['dl-abdtp-disabled']) {
                return;
            }
            var nextView = this._nextView[this._model.viewName];
            if ((this.minView || 'minute') === this._model.viewName) {
                this.value = this._dateAdapter.fromMilliseconds(dateButton.value);
                nextView = this.startView;
            }
            this.model = this._viewToModelProvider[nextView].getModel(dateButton.value, this.valueOf);
            this.onTouch();
        };
        /**
         * Handles click (and enter & space key down) events on the left button.
         *
         * Changes the displayed time range of the picker to the previous time range.
         * For example, in year view, the previous decade is displayed.
         *
         * @internal
         **/
        DlDateTimePickerComponent.prototype._onLeftClick = function () {
            this.model = this._viewToModelProvider[this._model.viewName].getModel(this._model.leftButton.value, this.valueOf);
            this.onTouch();
        };
        /**
         * Handles click (and enter & space key down) events on the up button.
         *
         * Changes the view of the picker to the next largest time increment.
         * For example, in day view, the next view displayed will be month view.
         *
         * @internal
         **/
        DlDateTimePickerComponent.prototype._onUpClick = function () {
            this.model = this._viewToModelProvider[this._previousView[this._model.viewName]].getModel(this._model.upButton.value, this.valueOf);
        };
        /**
         * Handles click (and enter & space key down) events on the right button.
         *
         * Changes the displayed time range of the picker to the next time range.
         * For example, in year view, the next decade is displayed.
         *
         * @internal
         **/
        DlDateTimePickerComponent.prototype._onRightClick = function () {
            this.model = this._viewToModelProvider[this._model.viewName].getModel(this._model.rightButton.value, this.valueOf);
            this.onTouch();
        };
        /**
         * Handles various key down events to move the `active date` around the calendar.
         *
         * @internal
         **/
        DlDateTimePickerComponent.prototype._handleKeyDown = function ($event) {
            var functionName = keyCodeToModelProviderMethod[$event.key];
            if (functionName) {
                var modelProvider = this._viewToModelProvider[this._model.viewName];
                this.model = modelProvider[functionName](this._model.activeDate, this.valueOf);
                this.focusActiveCell();
                // Prevent unexpected default actions such as form submission.
                $event.preventDefault();
            }
        };
        /**
         * Implements ControlValueAccessor.registerOnChange to register change listeners.
         * @internal
         **/
        DlDateTimePickerComponent.prototype.registerOnChange = function (fn) {
            this._changed.push(fn);
        };
        /**
         * Implements ControlValueAccessor.registerOnTouched to register touch listeners.
         * @internal
         **/
        DlDateTimePickerComponent.prototype.registerOnTouched = function (fn) {
            this._touched.push(fn);
        };
        /**
         * Implements ControlValueAccessor.writeValue to store the value from the model.
         * @internal
         **/
        DlDateTimePickerComponent.prototype.writeValue = function (value) {
            this.value = value;
        };
        var DlDateTimePickerComponent_1;
        DlDateTimePickerComponent.ctorParameters = function () { return [
            { type: core.ElementRef },
            { type: core.NgZone },
            { type: DlDateAdapter },
            { type: DlYearModelProvider },
            { type: DlMonthModelProvider },
            { type: DlDayModelProvider },
            { type: DlHourModelProvider },
            { type: DlMinuteModelProvider }
        ]; };
        __decorate([
            core.Output()
        ], DlDateTimePickerComponent.prototype, "change", void 0);
        __decorate([
            core.Input()
        ], DlDateTimePickerComponent.prototype, "leftIconClass", void 0);
        __decorate([
            core.Input()
        ], DlDateTimePickerComponent.prototype, "maxView", void 0);
        __decorate([
            core.Input()
        ], DlDateTimePickerComponent.prototype, "minView", void 0);
        __decorate([
            core.Input()
        ], DlDateTimePickerComponent.prototype, "minuteStep", void 0);
        __decorate([
            core.Input()
        ], DlDateTimePickerComponent.prototype, "rightIconClass", void 0);
        __decorate([
            core.Input()
        ], DlDateTimePickerComponent.prototype, "selectFilter", void 0);
        __decorate([
            core.Input()
        ], DlDateTimePickerComponent.prototype, "startDate", void 0);
        __decorate([
            core.Input()
        ], DlDateTimePickerComponent.prototype, "startView", void 0);
        __decorate([
            core.Input()
        ], DlDateTimePickerComponent.prototype, "upIconClass", void 0);
        DlDateTimePickerComponent = DlDateTimePickerComponent_1 = __decorate([
            core.Component({
                changeDetection: core.ChangeDetectionStrategy.OnPush,
                preserveWhitespaces: false,
                providers: [
                    {
                        provide: forms.NG_VALUE_ACCESSOR,
                        useExisting: DlDateTimePickerComponent_1,
                        multi: true
                    }
                ],
                selector: 'dl-date-time-picker',
                template: "<div class=\"text-center dl-abdtp-{{_model.viewName}}-view\" [attr.data-dl-abdtp-view]=\"_model.viewName\">\n  <div class=\"row align-items-center no-gutters\">\n    <button class=\"col dl-abdtp-left-button align-items-center\"\n            type=\"button\"\n            [attr.aria-label]=\"_model.leftButton.ariaLabel\"\n            [attr.dl-abdtp-value]=\"_model.leftButton.value\"\n            [attr.title]=\"_model.leftButton.ariaLabel\"\n            (click)=\"_onLeftClick()\"\n    ><span class=\"left-icon\" [ngClass]=\"leftIconClass\"></span>\n    </button>\n\n    <div *ngIf=\"_model.viewName === (this.maxView || 'year'); then maxViewLabel else defaultViewLabel;\"></div>\n\n    <button class=\"col dl-abdtp-right-button\"\n            type=\"button\"\n            [attr.aria-label]=\"_model.rightButton.ariaLabel\"\n            [attr.dl-abdtp-value]=\"_model.rightButton.value\"\n            [attr.title]=\"_model.rightButton.ariaLabel\"\n            (click)=\"_onRightClick()\"\n    ><span class=\"right-icon\" [ngClass]=\"rightIconClass\"></span>\n    </button>\n  </div>\n  <div (keydown)=\"_handleKeyDown($event)\">\n    <div *ngIf=\"_model.rowLabels?.length\" class=\"row no-gutters\">\n      <div *ngFor=\"let label of _model.rowLabels\"\n           class=\"col align-items-center no-gutters dl-abdtp-col-label\">{{label}}</div>\n    </div>\n    <div *ngFor=\"let row of _model.rows\" class=\"row align-items-center no-gutters\">\n      <div *ngFor=\"let cell of row.cells\"\n           role=\"gridcell\"\n           class=\"col dl-abdtp-date-button dl-abdtp-{{_model.viewName}}\"\n           [ngClass]=\"cell.classes\"\n           [attr.aria-label]=\"cell.ariaLabel\"\n           [attr.aria-disabled]=\"cell.classes['dl-abdtp-disabled']\"\n           [attr.dl-abdtp-value]=\"cell.value\"\n           [attr.tabindex]=\"cell.classes['dl-abdtp-active'] ? 0 : -1\"\n           (click)=\"_onDateClick(cell)\"\n           (keydown.space)=\"_onDateClick(cell)\"\n           (keydown.enter)=\"_onDateClick(cell)\"\n      >{{cell.display}}</div>\n    </div>\n  </div>\n</div>\n\n<ng-template #maxViewLabel>\n  <div class=\"col-10 dl-abdtp-view-label\">{{_model.viewLabel}}</div>\n</ng-template>\n<ng-template #defaultViewLabel>\n  <button class=\"col-10 dl-abdtp-view-label dl-abdtp-up-button\"\n          type=\"button\"\n          [attr.aria-label]=\"_model.upButton.ariaLabel\"\n          [attr.dl-abdtp-value]=\"_model.upButton.value\"\n          [attr.title]=\"_model.upButton.ariaLabel\"\n          (click)=\"_onUpClick()\"\n          [ngClass]=\"_model.upButton.classes\"\n  >{{_model.viewLabel}}&nbsp;<span class=\"up-icon\" [ngClass]=\"upIconClass\"></span>\n  </button>\n</ng-template>\n",
                styles: [":host{-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}.dl-abdtp-col-label,.dl-abdtp-view-label{font-weight:700}.dl-abdtp-date-button,.dl-abdtp-left-button,.dl-abdtp-right-button,.dl-abdtp-view-label{padding:5px;border-radius:999px;cursor:pointer;color:rgba(0,0,0,.87);outline:0}.dl-abdtp-date-button,.dl-abdtp-left-button,.dl-abdtp-right-button,.dl-abdtp-up-button{border-width:0}.dl-abdtp-active:focus,.dl-abdtp-date-button:focus,.dl-abdtp-date-button:hover,.dl-abdtp-left-button:focus,.dl-abdtp-left-button:hover,.dl-abdtp-right-button:focus,.dl-abdtp-right-button:hover,.dl-abdtp-up-button:focus,.dl-abdtp-up-button:hover,.dl-abdtp-view-label:focus{background:rgba(0,0,0,.04)}.dl-abdtp-future,.dl-abdtp-past{color:rgba(0,0,0,.04)}.dl-abdtp-now,.dl-abdtp-now.disabled,.dl-abdtp-now.disabled:hover,.dl-abdtp-now:hover{border-radius:999px;border:1px solid rgba(0,0,0,.25)}.dl-abdtp-selected{color:#fff;background:rgba(0,82,204,.75)}.dl-abdtp-selected:focus,.dl-abdtp-selected:hover{background:#0052cc}.dl-abdtp-disabled{cursor:default;color:rgba(0,0,0,.25)}"]
            })
        ], DlDateTimePickerComponent);
        return DlDateTimePickerComponent;
    }());
    /** @internal */
    function hasValue(value) {
        return (typeof value !== 'undefined') && (value !== null);
    }

    /**
     * @license
     * Copyright 2013-present Dale Lotts All Rights Reserved.
     * http://www.dalelotts.com
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at https://github.com/dalelotts/angular-bootstrap-datetimepicker/blob/master/LICENSE
     */
    /**
     * Import this module to supply your own `DateAdapter` provider.
     * @internal
     **/
    var DlDateTimePickerModule = /** @class */ (function () {
        function DlDateTimePickerModule() {
        }
        DlDateTimePickerModule = __decorate([
            core.NgModule({
                declarations: [DlDateTimePickerComponent],
                imports: [common.CommonModule],
                exports: [DlDateTimePickerComponent],
                providers: [
                    DlYearModelProvider,
                    DlMonthModelProvider,
                    DlDayModelProvider,
                    DlHourModelProvider,
                    DlMinuteModelProvider
                ],
            })
        ], DlDateTimePickerModule);
        return DlDateTimePickerModule;
    }());

    exports.DL_DATE_TIME_DISPLAY_FORMAT = DL_DATE_TIME_DISPLAY_FORMAT;
    exports.DL_DATE_TIME_DISPLAY_FORMAT_DEFAULT = DL_DATE_TIME_DISPLAY_FORMAT_DEFAULT;
    exports.DL_DATE_TIME_INPUT_FORMATS = DL_DATE_TIME_INPUT_FORMATS;
    exports.DL_DATE_TIME_INPUT_FORMATS_DEFAULT = DL_DATE_TIME_INPUT_FORMATS_DEFAULT;
    exports.DL_DATE_TIME_MODEL_FORMAT = DL_DATE_TIME_MODEL_FORMAT;
    exports.DL_DATE_TIME_MODEL_FORMAT_DEFAULT = DL_DATE_TIME_MODEL_FORMAT_DEFAULT;
    exports.DlDateAdapter = DlDateAdapter;
    exports.DlDateAdapterMoment = DlDateAdapterMoment;
    exports.DlDateAdapterNative = DlDateAdapterNative;
    exports.DlDateAdapterNumber = DlDateAdapterNumber;
    exports.DlDateAdapterString = DlDateAdapterString;
    exports.DlDateTimeCoreModule = DlDateTimeCoreModule;
    exports.DlDateTimeDateModule = DlDateTimeDateModule;
    exports.DlDateTimeInputChange = DlDateTimeInputChange;
    exports.DlDateTimeInputDirective = DlDateTimeInputDirective;
    exports.DlDateTimeInputModule = DlDateTimeInputModule;
    exports.DlDateTimeMomentModule = DlDateTimeMomentModule;
    exports.DlDateTimeNumberModule = DlDateTimeNumberModule;
    exports.DlDateTimePickerChange = DlDateTimePickerChange;
    exports.DlDateTimePickerComponent = DlDateTimePickerComponent;
    exports.DlDateTimePickerModule = DlDateTimePickerModule;
    exports.DlDateTimeStringModule = DlDateTimeStringModule;
    exports.DlDayModelProvider = DlDayModelProvider;
    exports.DlHourModelProvider = DlHourModelProvider;
    exports.DlMinuteModelProvider = DlMinuteModelProvider;
    exports.DlMonthModelProvider = DlMonthModelProvider;
    exports.DlYearModelProvider = DlYearModelProvider;
    exports.ɵ0 = ɵ0;
    exports.ɵ1 = ɵ1;
    exports.ɵ2 = ɵ2;
    exports.ɵ3 = ɵ3;
    exports.ɵ4 = ɵ4;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=angular-bootstrap-datetimepicker.umd.js.map
