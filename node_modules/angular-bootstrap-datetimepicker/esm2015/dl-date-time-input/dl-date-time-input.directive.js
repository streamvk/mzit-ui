var DlDateTimeInputDirective_1;
import * as tslib_1 from "tslib";
import { Directive, ElementRef, EventEmitter, HostListener, Inject, Input, Output, Renderer2 } from '@angular/core';
import { NG_VALIDATORS, NG_VALUE_ACCESSOR, Validators, } from '@angular/forms';
import * as _moment from 'moment';
import { DL_DATE_TIME_DISPLAY_FORMAT, DL_DATE_TIME_INPUT_FORMATS, DlDateAdapter } from '../core/public-api';
import { DlDateTimeInputChange } from './dl-date-time-input-change';
/**
 * @internal
 */
const moment = _moment;
/**
 *  This directive allows the user to enter dates, using the keyboard, into an input box and
 *  angular will then store a date value in the model.
 *
 *  The input format(s), display format, and model format are independent and fully customizable.
 */
let DlDateTimeInputDirective = DlDateTimeInputDirective_1 = class DlDateTimeInputDirective {
    /**
     * Constructs a new instance of this directive.
     * @param _renderer
     *  reference to the renderer.
     * @param _elementRef
     *  reference to this element.
     * @param _dateAdapter
     *  date adapter for the date type in the model.
     * @param _displayFormat
     *  from `DL_DATE_TIME_DISPLAY_FORMAT`, which defines the format to use for a valid date/time value.
     * @param _inputFormats
     *  from `DL_DATE_TIME_INPUT_FORMATS`, which defines the input formats that allowed as valid date/time values.
     *  NB: moment is always in strict parse mode for this directive.
     */
    constructor(_renderer, _elementRef, _dateAdapter, _displayFormat, _inputFormats) {
        this._renderer = _renderer;
        this._elementRef = _elementRef;
        this._dateAdapter = _dateAdapter;
        this._displayFormat = _displayFormat;
        this._inputFormats = _inputFormats;
        /* tslint:disable:member-ordering */
        this._filterValidator = (control) => {
            // @ts-ignore
            return (this._inputFilter || (() => true))(this._value) ?
                null : { 'dlDateTimeInputFilter': { 'value': control.value } };
        };
        this._inputFilter = () => true;
        this._isValid = true;
        this._parseValidator = () => {
            return this._isValid ?
                null : { 'dlDateTimeInputParse': { 'text': this._elementRef.nativeElement.value } };
        };
        this._changed = [];
        this._touched = [];
        this._validator = Validators.compose([this._parseValidator, this._filterValidator]);
        this._onValidatorChange = () => { };
        this._value = undefined;
        /**
         * Emits when a `change` event when date/time is selected or
         * the value of the date/time picker changes.
         **/
        this.dateChange = new EventEmitter();
    }
    /**
     * Set a function used to determine whether or not the `value` entered by the user is allowed.
     * @param inputFilterFunction
     *   a function that returns `true` if the `value` entered by the user is allowed, otherwise `false`.
     */
    set dlDateTimeInputFilter(inputFilterFunction) {
        this._inputFilter = inputFilterFunction || (() => true);
        this._onValidatorChange();
    }
    /* tslint:enable:member-ordering */
    /**
     * Returns `D` value of the date/time input or `undefined` | `null` if no value is set.
     **/
    get value() {
        return this._value;
    }
    /**
     * Set the value of the date/time input to a value of `D` | `undefined` | `null`;
     * @param newValue
     *  the new value of the date/time input
     */
    set value(newValue) {
        if (newValue !== this._value) {
            this._value = newValue;
            this._changed.forEach(onChanged => onChanged(this._value));
        }
    }
    /**
     * Emit a `change` event when the value of the input changes.
     */
    _onChange() {
        this.dateChange.emit(new DlDateTimeInputChange(this._value));
    }
    /**
     * Format the input text using {@link DL_DATE_TIME_DISPLAY_FORMAT} and mark the control as touched.
     */
    _onBlur() {
        if (this._value) {
            this._setElementValue(this._value);
        }
        this._touched.forEach(onTouched => onTouched());
    }
    /**
     * Parse the user input into a possibly valid date.
     * The model value is not set if the input is NOT one of the {@link DL_DATE_TIME_INPUT_FORMATS}.
     * @param value
     *   Value of the input control.
     */
    _onInput(value) {
        const testDate = value === null || value === undefined || value === ''
            ? undefined
            : moment(value, this._inputFormats, true);
        this._isValid = testDate && testDate.isValid();
        this.value = this._isValid ? this._dateAdapter.fromMilliseconds(testDate.valueOf()) : undefined;
    }
    /**
     * @internal
     */
    _setElementValue(value) {
        if (value !== null && value !== undefined) {
            this._renderer.setProperty(this._elementRef.nativeElement, 'value', moment(value).format(this._displayFormat));
        }
    }
    /**
     * @internal
     */
    registerOnChange(onChange) {
        this._changed.push(onChange);
    }
    /**
     * @internal
     */
    registerOnTouched(onTouched) {
        this._touched.push(onTouched);
    }
    /**
     * @internal
     */
    registerOnValidatorChange(validatorOnChange) {
        this._onValidatorChange = validatorOnChange;
    }
    /**
     * @internal
     */
    setDisabledState(isDisabled) {
        this._renderer.setProperty(this._elementRef.nativeElement, 'disabled', isDisabled);
    }
    /**
     * @internal
     */
    validate(control) {
        return this._validator(control);
    }
    /**
     * @internal
     */
    writeValue(value) {
        this._isValid = true;
        this.value = value;
        this._setElementValue(value);
    }
};
DlDateTimeInputDirective.ctorParameters = () => [
    { type: Renderer2 },
    { type: ElementRef },
    { type: DlDateAdapter },
    { type: String, decorators: [{ type: Inject, args: [DL_DATE_TIME_DISPLAY_FORMAT,] }] },
    { type: Array, decorators: [{ type: Inject, args: [DL_DATE_TIME_INPUT_FORMATS,] }] }
];
tslib_1.__decorate([
    Output()
], DlDateTimeInputDirective.prototype, "dateChange", void 0);
tslib_1.__decorate([
    Input()
], DlDateTimeInputDirective.prototype, "dlDateTimeInputFilter", null);
tslib_1.__decorate([
    HostListener('change')
], DlDateTimeInputDirective.prototype, "_onChange", null);
tslib_1.__decorate([
    HostListener('blur')
], DlDateTimeInputDirective.prototype, "_onBlur", null);
tslib_1.__decorate([
    HostListener('input', ['$event.target.value'])
], DlDateTimeInputDirective.prototype, "_onInput", null);
DlDateTimeInputDirective = DlDateTimeInputDirective_1 = tslib_1.__decorate([
    Directive({
        selector: 'input[dlDateTimeInput]',
        providers: [
            { provide: NG_VALUE_ACCESSOR, useExisting: DlDateTimeInputDirective_1, multi: true },
            { provide: NG_VALIDATORS, useExisting: DlDateTimeInputDirective_1, multi: true }
        ]
    }),
    tslib_1.__param(3, Inject(DL_DATE_TIME_DISPLAY_FORMAT)),
    tslib_1.__param(4, Inject(DL_DATE_TIME_INPUT_FORMATS))
], DlDateTimeInputDirective);
export { DlDateTimeInputDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGwtZGF0ZS10aW1lLWlucHV0LmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL2FuZ3VsYXItYm9vdHN0cmFwLWRhdGV0aW1lcGlja2VyLyIsInNvdXJjZXMiOlsiZGwtZGF0ZS10aW1lLWlucHV0L2RsLWRhdGUtdGltZS1pbnB1dC5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7QUFBQSxPQUFPLEVBQUMsU0FBUyxFQUFFLFVBQVUsRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsTUFBTSxFQUFFLFNBQVMsRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUNsSCxPQUFPLEVBR0wsYUFBYSxFQUNiLGlCQUFpQixFQUlqQixVQUFVLEdBQ1gsTUFBTSxnQkFBZ0IsQ0FBQztBQUN4QixPQUFPLEtBQUssT0FBTyxNQUFNLFFBQVEsQ0FBQztBQUNsQyxPQUFPLEVBQUMsMkJBQTJCLEVBQUUsMEJBQTBCLEVBQUUsYUFBYSxFQUFDLE1BQU0sb0JBQW9CLENBQUM7QUFDMUcsT0FBTyxFQUFDLHFCQUFxQixFQUFDLE1BQU0sNkJBQTZCLENBQUM7QUFFbEU7O0dBRUc7QUFDSCxNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUM7QUFFdkI7Ozs7O0dBS0c7QUFRSCxJQUFhLHdCQUF3QixnQ0FBckMsTUFBYSx3QkFBd0I7SUEyQm5DOzs7Ozs7Ozs7Ozs7O09BYUc7SUFDSCxZQUNVLFNBQW9CLEVBQ3BCLFdBQXVCLEVBQ3ZCLFlBQThCLEVBQ2dCLGNBQXNCLEVBQ3ZCLGFBQXVCO1FBSnBFLGNBQVMsR0FBVCxTQUFTLENBQVc7UUFDcEIsZ0JBQVcsR0FBWCxXQUFXLENBQVk7UUFDdkIsaUJBQVksR0FBWixZQUFZLENBQWtCO1FBQ2dCLG1CQUFjLEdBQWQsY0FBYyxDQUFRO1FBQ3ZCLGtCQUFhLEdBQWIsYUFBYSxDQUFVO1FBNUM5RSxvQ0FBb0M7UUFDNUIscUJBQWdCLEdBQWdCLENBQUMsT0FBd0IsRUFBMkIsRUFBRTtZQUM1Rixh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SCxVQUFVLENBQUMsS0FBUTtRQUNqQixJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQztRQUNyQixJQUFJLENBQUMsS0FBSyxHQUFHLEtBQUssQ0FBQztRQUNuQixJQUFJLENBQUMsZ0JBQWdCLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDL0IsQ0FBQztDQUNGLENBQUE7O1lBNUhzQixTQUFTO1lBQ1AsVUFBVTtZQUNULGFBQWE7eUNBQ2xDLE1BQU0sU0FBQywyQkFBMkI7d0NBQ2xDLE1BQU0sU0FBQywwQkFBMEI7O0FBckJwQztJQURDLE1BQU0sRUFBRTs0REFDMEQ7QUE4Qm5FO0lBREMsS0FBSyxFQUFFO3FFQUlQO0FBMkJ1QjtJQUF2QixZQUFZLENBQUMsUUFBUSxDQUFDO3lEQUV0QjtBQUtxQjtJQUFyQixZQUFZLENBQUMsTUFBTSxDQUFDO3VEQUtwQjtBQVErQztJQUEvQyxZQUFZLENBQUMsT0FBTyxFQUFFLENBQUMscUJBQXFCLENBQUMsQ0FBQzt3REFPOUM7QUFoSFUsd0JBQXdCO0lBUHBDLFNBQVMsQ0FBQztRQUNULFFBQVEsRUFBRSx3QkFBd0I7UUFDbEMsU0FBUyxFQUFFO1lBQ1QsRUFBQyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsV0FBVyxFQUFHLDBCQUF3QixFQUFFLEtBQUssRUFBRSxJQUFJLEVBQUM7WUFDakYsRUFBQyxPQUFPLEVBQUUsYUFBYSxFQUFFLFdBQVcsRUFBRywwQkFBd0IsRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFDO1NBQzlFO0tBQ0YsQ0FBQztJQThDRyxtQkFBQSxNQUFNLENBQUMsMkJBQTJCLENBQUMsQ0FBQTtJQUNuQyxtQkFBQSxNQUFNLENBQUMsMEJBQTBCLENBQUMsQ0FBQTtHQTlDMUIsd0JBQXdCLENBc0twQztTQXRLWSx3QkFBd0IiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge0RpcmVjdGl2ZSwgRWxlbWVudFJlZiwgRXZlbnRFbWl0dGVyLCBIb3N0TGlzdGVuZXIsIEluamVjdCwgSW5wdXQsIE91dHB1dCwgUmVuZGVyZXIyfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIEFic3RyYWN0Q29udHJvbCxcbiAgQ29udHJvbFZhbHVlQWNjZXNzb3IsXG4gIE5HX1ZBTElEQVRPUlMsXG4gIE5HX1ZBTFVFX0FDQ0VTU09SLFxuICBWYWxpZGF0aW9uRXJyb3JzLFxuICBWYWxpZGF0b3IsXG4gIFZhbGlkYXRvckZuLFxuICBWYWxpZGF0b3JzLFxufSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQgKiBhcyBfbW9tZW50IGZyb20gJ21vbWVudCc7XG5pbXBvcnQge0RMX0RBVEVfVElNRV9ESVNQTEFZX0ZPUk1BVCwgRExfREFURV9USU1FX0lOUFVUX0ZPUk1BVFMsIERsRGF0ZUFkYXB0ZXJ9IGZyb20gJy4uL2NvcmUvcHVibGljLWFwaSc7XG5pbXBvcnQge0RsRGF0ZVRpbWVJbnB1dENoYW5nZX0gZnJvbSAnLi9kbC1kYXRlLXRpbWUtaW5wdXQtY2hhbmdlJztcblxuLyoqXG4gKiBAaW50ZXJuYWxcbiAqL1xuY29uc3QgbW9tZW50ID0gX21vbWVudDtcblxuLyoqXG4gKiAgVGhpcyBkaXJlY3RpdmUgYWxsb3dzIHRoZSB1c2VyIHRvIGVudGVyIGRhdGVzLCB1c2luZyB0aGUga2V5Ym9hcmQsIGludG8gYW4gaW5wdXQgYm94IGFuZFxuICogIGFuZ3VsYXIgd2lsbCB0aGVuIHN0b3JlIGEgZGF0ZSB2YWx1ZSBpbiB0aGUgbW9kZWwuXG4gKlxuICogIFRoZSBpbnB1dCBmb3JtYXQocyksIGRpc3BsYXkgZm9ybWF0LCBhbmQgbW9kZWwgZm9ybWF0IGFyZSBpbmRlcGVuZGVudCBhbmQgZnVsbHkgY3VzdG9taXphYmxlLlxuICovXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdpbnB1dFtkbERhdGVUaW1lSW5wdXRdJyxcbiAgcHJvdmlkZXJzOiBbXG4gICAge3Byb3ZpZGU6IE5HX1ZBTFVFX0FDQ0VTU09SLCB1c2VFeGlzdGluZzogIERsRGF0ZVRpbWVJbnB1dERpcmVjdGl2ZSwgbXVsdGk6IHRydWV9LFxuICAgIHtwcm92aWRlOiBOR19WQUxJREFUT1JTLCB1c2VFeGlzdGluZzogIERsRGF0ZVRpbWVJbnB1dERpcmVjdGl2ZSwgbXVsdGk6IHRydWV9XG4gIF1cbn0pXG5leHBvcnQgY2xhc3MgRGxEYXRlVGltZUlucHV0RGlyZWN0aXZlPEQ+IGltcGxlbWVudHMgQ29udHJvbFZhbHVlQWNjZXNzb3IsIFZhbGlkYXRvciB7XG5cbiAgLyogdHNsaW50OmRpc2FibGU6bWVtYmVyLW9yZGVyaW5nICovXG4gIHByaXZhdGUgX2ZpbHRlclZhbGlkYXRvcjogVmFsaWRhdG9yRm4gPSAoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT4ge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICByZXR1cm4gKHRoaXMuX2lucHV0RmlsdGVyIHx8ICgoKSA9PiB0cnVlKSkodGhpcy5fdmFsdWUpID9cbiAgICAgIG51bGwgOiB7J2RsRGF0ZVRpbWVJbnB1dEZpbHRlcic6IHsndmFsdWUnOiBjb250cm9sLnZhbHVlfX07XG4gIH1cbiAgcHJpdmF0ZSBfaW5wdXRGaWx0ZXI6ICh2YWx1ZTogKEQgfCBudWxsKSkgPT4gYm9vbGVhbiA9ICgpID0+IHRydWU7XG4gIHByaXZhdGUgX2lzVmFsaWQgPSB0cnVlO1xuICBwcml2YXRlIF9wYXJzZVZhbGlkYXRvcjogVmFsaWRhdG9yRm4gPSAoKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwgPT4ge1xuICAgIHJldHVybiB0aGlzLl9pc1ZhbGlkID9cbiAgICAgIG51bGwgOiB7J2RsRGF0ZVRpbWVJbnB1dFBhcnNlJzogeyd0ZXh0JzogdGhpcy5fZWxlbWVudFJlZi5uYXRpdmVFbGVtZW50LnZhbHVlfX07XG4gIH1cbiAgcHJpdmF0ZSBfY2hhbmdlZDogKCh2YWx1ZTogRCkgPT4gdm9pZClbXSA9IFtdO1xuICBwcml2YXRlIF90b3VjaGVkOiAoKCkgPT4gdm9pZClbXSA9IFtdO1xuICBwcml2YXRlIF92YWxpZGF0b3IgPSBWYWxpZGF0b3JzLmNvbXBvc2UoW3RoaXMuX3BhcnNlVmFsaWRhdG9yLCB0aGlzLl9maWx0ZXJWYWxpZGF0b3JdKTtcbiAgcHJpdmF0ZSBfb25WYWxpZGF0b3JDaGFuZ2U6ICgpID0+IHZvaWQgPSAoKSA9PiB7fTtcbiAgcHJpdmF0ZSBfdmFsdWU6IEQgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIEVtaXRzIHdoZW4gYSBgY2hhbmdlYCBldmVudCB3aGVuIGRhdGUvdGltZSBpcyBzZWxlY3RlZCBvclxuICAgKiB0aGUgdmFsdWUgb2YgdGhlIGRhdGUvdGltZSBwaWNrZXIgY2hhbmdlcy5cbiAgICoqL1xuICBAT3V0cHV0KClcbiAgcmVhZG9ubHkgZGF0ZUNoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8RGxEYXRlVGltZUlucHV0Q2hhbmdlPEQ+PigpO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RzIGEgbmV3IGluc3RhbmNlIG9mIHRoaXMgZGlyZWN0aXZlLlxuICAgKiBAcGFyYW0gX3JlbmRlcmVyXG4gICAqICByZWZlcmVuY2UgdG8gdGhlIHJlbmRlcmVyLlxuICAgKiBAcGFyYW0gX2VsZW1lbnRSZWZcbiAgICogIHJlZmVyZW5jZSB0byB0aGlzIGVsZW1lbnQuXG4gICAqIEBwYXJhbSBfZGF0ZUFkYXB0ZXJcbiAgICogIGRhdGUgYWRhcHRlciBmb3IgdGhlIGRhdGUgdHlwZSBpbiB0aGUgbW9kZWwuXG4gICAqIEBwYXJhbSBfZGlzcGxheUZvcm1hdFxuICAgKiAgZnJvbSBgRExfREFURV9USU1FX0RJU1BMQVlfRk9STUFUYCwgd2hpY2ggZGVmaW5lcyB0aGUgZm9ybWF0IHRvIHVzZSBmb3IgYSB2YWxpZCBkYXRlL3RpbWUgdmFsdWUuXG4gICAqIEBwYXJhbSBfaW5wdXRGb3JtYXRzXG4gICAqICBmcm9tIGBETF9EQVRFX1RJTUVfSU5QVVRfRk9STUFUU2AsIHdoaWNoIGRlZmluZXMgdGhlIGlucHV0IGZvcm1hdHMgdGhhdCBhbGxvd2VkIGFzIHZhbGlkIGRhdGUvdGltZSB2YWx1ZXMuXG4gICAqICBOQjogbW9tZW50IGlzIGFsd2F5cyBpbiBzdHJpY3QgcGFyc2UgbW9kZSBmb3IgdGhpcyBkaXJlY3RpdmUuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIF9yZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIHByaXZhdGUgX2VsZW1lbnRSZWY6IEVsZW1lbnRSZWYsXG4gICAgcHJpdmF0ZSBfZGF0ZUFkYXB0ZXI6IERsRGF0ZUFkYXB0ZXI8RD4sXG4gICAgQEluamVjdChETF9EQVRFX1RJTUVfRElTUExBWV9GT1JNQVQpIHByaXZhdGUgcmVhZG9ubHkgX2Rpc3BsYXlGb3JtYXQ6IHN0cmluZyxcbiAgICBASW5qZWN0KERMX0RBVEVfVElNRV9JTlBVVF9GT1JNQVRTKSBwcml2YXRlIHJlYWRvbmx5IF9pbnB1dEZvcm1hdHM6IHN0cmluZ1tdXG4gICkge31cblxuICAvKipcbiAgICogU2V0IGEgZnVuY3Rpb24gdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciBvciBub3QgdGhlIGB2YWx1ZWAgZW50ZXJlZCBieSB0aGUgdXNlciBpcyBhbGxvd2VkLlxuICAgKiBAcGFyYW0gaW5wdXRGaWx0ZXJGdW5jdGlvblxuICAgKiAgIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBlbnRlcmVkIGJ5IHRoZSB1c2VyIGlzIGFsbG93ZWQsIG90aGVyd2lzZSBgZmFsc2VgLlxuICAgKi9cbiAgQElucHV0KClcbiAgc2V0IGRsRGF0ZVRpbWVJbnB1dEZpbHRlcihpbnB1dEZpbHRlckZ1bmN0aW9uOiAodmFsdWU6IEQgfCBudWxsKSA9PiBib29sZWFuKSB7XG4gICAgdGhpcy5faW5wdXRGaWx0ZXIgPSBpbnB1dEZpbHRlckZ1bmN0aW9uIHx8ICgoKSA9PiB0cnVlKTtcbiAgICB0aGlzLl9vblZhbGlkYXRvckNoYW5nZSgpO1xuICB9XG5cbiAgLyogdHNsaW50OmVuYWJsZTptZW1iZXItb3JkZXJpbmcgKi9cblxuICAvKipcbiAgICogUmV0dXJucyBgRGAgdmFsdWUgb2YgdGhlIGRhdGUvdGltZSBpbnB1dCBvciBgdW5kZWZpbmVkYCB8IGBudWxsYCBpZiBubyB2YWx1ZSBpcyBzZXQuXG4gICAqKi9cbiAgZ2V0IHZhbHVlKCk6IEQge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgaW5wdXQgdG8gYSB2YWx1ZSBvZiBgRGAgfCBgdW5kZWZpbmVkYCB8IGBudWxsYDtcbiAgICogQHBhcmFtIG5ld1ZhbHVlXG4gICAqICB0aGUgbmV3IHZhbHVlIG9mIHRoZSBkYXRlL3RpbWUgaW5wdXRcbiAgICovXG5cbiAgc2V0IHZhbHVlKG5ld1ZhbHVlOiBEIHwgbnVsbCB8IHVuZGVmaW5lZCkge1xuICAgIGlmIChuZXdWYWx1ZSAhPT0gdGhpcy5fdmFsdWUpIHtcbiAgICAgIHRoaXMuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICB0aGlzLl9jaGFuZ2VkLmZvckVhY2gob25DaGFuZ2VkID0+IG9uQ2hhbmdlZCh0aGlzLl92YWx1ZSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IGEgYGNoYW5nZWAgZXZlbnQgd2hlbiB0aGUgdmFsdWUgb2YgdGhlIGlucHV0IGNoYW5nZXMuXG4gICAqL1xuICBASG9zdExpc3RlbmVyKCdjaGFuZ2UnKSBfb25DaGFuZ2UoKSB7XG4gICAgdGhpcy5kYXRlQ2hhbmdlLmVtaXQobmV3IERsRGF0ZVRpbWVJbnB1dENoYW5nZSh0aGlzLl92YWx1ZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcm1hdCB0aGUgaW5wdXQgdGV4dCB1c2luZyB7QGxpbmsgRExfREFURV9USU1FX0RJU1BMQVlfRk9STUFUfSBhbmQgbWFyayB0aGUgY29udHJvbCBhcyB0b3VjaGVkLlxuICAgKi9cbiAgQEhvc3RMaXN0ZW5lcignYmx1cicpIF9vbkJsdXIoKSB7XG4gICAgaWYgKHRoaXMuX3ZhbHVlKSB7XG4gICAgICB0aGlzLl9zZXRFbGVtZW50VmFsdWUodGhpcy5fdmFsdWUpO1xuICAgIH1cbiAgICB0aGlzLl90b3VjaGVkLmZvckVhY2gob25Ub3VjaGVkID0+IG9uVG91Y2hlZCgpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgdXNlciBpbnB1dCBpbnRvIGEgcG9zc2libHkgdmFsaWQgZGF0ZS5cbiAgICogVGhlIG1vZGVsIHZhbHVlIGlzIG5vdCBzZXQgaWYgdGhlIGlucHV0IGlzIE5PVCBvbmUgb2YgdGhlIHtAbGluayBETF9EQVRFX1RJTUVfSU5QVVRfRk9STUFUU30uXG4gICAqIEBwYXJhbSB2YWx1ZVxuICAgKiAgIFZhbHVlIG9mIHRoZSBpbnB1dCBjb250cm9sLlxuICAgKi9cbiAgQEhvc3RMaXN0ZW5lcignaW5wdXQnLCBbJyRldmVudC50YXJnZXQudmFsdWUnXSkgX29uSW5wdXQodmFsdWU6IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQpOiB2b2lkIHtcbiAgICBjb25zdCB0ZXN0RGF0ZSA9IHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09ICcnXG4gICAgICA/IHVuZGVmaW5lZFxuICAgICAgOiBtb21lbnQodmFsdWUsIHRoaXMuX2lucHV0Rm9ybWF0cywgdHJ1ZSk7XG5cbiAgICB0aGlzLl9pc1ZhbGlkID0gdGVzdERhdGUgJiYgdGVzdERhdGUuaXNWYWxpZCgpO1xuICAgIHRoaXMudmFsdWUgPSB0aGlzLl9pc1ZhbGlkID8gdGhpcy5fZGF0ZUFkYXB0ZXIuZnJvbU1pbGxpc2Vjb25kcyh0ZXN0RGF0ZS52YWx1ZU9mKCkpIDogdW5kZWZpbmVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcHJpdmF0ZSBfc2V0RWxlbWVudFZhbHVlKHZhbHVlOiBEKSB7XG4gICAgaWYgKHZhbHVlICE9PSBudWxsICYmIHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFByb3BlcnR5KHRoaXMuX2VsZW1lbnRSZWYubmF0aXZlRWxlbWVudCwgJ3ZhbHVlJywgbW9tZW50KHZhbHVlKS5mb3JtYXQodGhpcy5fZGlzcGxheUZvcm1hdCkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlZ2lzdGVyT25DaGFuZ2Uob25DaGFuZ2U6ICh2YWx1ZTogYW55KSA9PiB2b2lkKTogdm9pZCB7XG4gICAgdGhpcy5fY2hhbmdlZC5wdXNoKG9uQ2hhbmdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHJlZ2lzdGVyT25Ub3VjaGVkKG9uVG91Y2hlZDogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMuX3RvdWNoZWQucHVzaChvblRvdWNoZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgcmVnaXN0ZXJPblZhbGlkYXRvckNoYW5nZSh2YWxpZGF0b3JPbkNoYW5nZTogKCkgPT4gdm9pZCk6IHZvaWQge1xuICAgIHRoaXMuX29uVmFsaWRhdG9yQ2hhbmdlID0gdmFsaWRhdG9yT25DaGFuZ2U7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICBzZXREaXNhYmxlZFN0YXRlKGlzRGlzYWJsZWQ6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICB0aGlzLl9yZW5kZXJlci5zZXRQcm9wZXJ0eSh0aGlzLl9lbGVtZW50UmVmLm5hdGl2ZUVsZW1lbnQsICdkaXNhYmxlZCcsIGlzRGlzYWJsZWQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBpbnRlcm5hbFxuICAgKi9cbiAgdmFsaWRhdGUoY29udHJvbDogQWJzdHJhY3RDb250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGwge1xuICAgIHJldHVybiB0aGlzLl92YWxpZGF0b3IoY29udHJvbCk7XG4gIH1cblxuICAvKipcbiAgICogQGludGVybmFsXG4gICAqL1xuICB3cml0ZVZhbHVlKHZhbHVlOiBEKTogdm9pZCB7XG4gICAgdGhpcy5faXNWYWxpZCA9IHRydWU7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMuX3NldEVsZW1lbnRWYWx1ZSh2YWx1ZSk7XG4gIH1cbn1cbiJdfQ==